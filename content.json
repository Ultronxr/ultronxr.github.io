{"meta":{"title":"Ultronxr's Blog","subtitle":"Ultronxr's Blog","description":"Do something you have never done.","author":"ultronxr","url":"https://ultronxr.xyz"},"pages":[{"title":"","date":"2018-12-20T12:39:49.872Z","updated":"2018-12-20T12:39:49.872Z","comments":false,"path":"categories/index.html","permalink":"https://ultronxr.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-20T12:39:33.328Z","updated":"2018-12-20T12:39:33.328Z","comments":false,"path":"tags/index.html","permalink":"https://ultronxr.xyz/tags/index.html","excerpt":"","text":""},{"title":"About 关于","date":"2018-12-21T16:00:00.000Z","updated":"2019-02-28T09:39:13.999Z","comments":false,"path":"about/index.html","permalink":"https://ultronxr.xyz/about/index.html","excerpt":"","text":"关于我这里摘录一些学习工作中遇到的问题，以及一些容易忘的tips。 我的GitHub； 关于此博客本博客基于Hexo框架； 主题来自GitHub用户yscoder的hexo-theme-indigo，特此感谢； 评论系统基于Valine； 网站统计工具来自不蒜子。 日志 2018.08.08 基于jekyll创建个人博客，并部署在github.io上。 2018.12.20 博客迁移至Hexo。 2018.12.21 添加解析域名：https://ultronxr.xyz 。 2019.02.28 域名 ultronxr.xyz 备案完成，备案号：浙ICP备19007617号-1 。"}],"posts":[{"title":"Windows环境下搭建go-gtk的方法以及过程中一些问题的解决办法","slug":"Building-env-of-go-gtk-in-Windows","date":"2019-04-02T08:57:27.000Z","updated":"2019-04-10T07:47:06.172Z","comments":true,"path":"2019/04/02/Building-env-of-go-gtk-in-Windows/","link":"","permalink":"https://ultronxr.xyz/2019/04/02/Building-env-of-go-gtk-in-Windows/","excerpt":"最近打算做一个桌面应用程序，然后也打算学一波go语言，所以就借此机会用go写一个带界面的程序。我是用了go-gtk，这里记录一下环境搭建的过程，以及搭建时候踩的四个坑（有坑的地方我着重标出来了）。","text":"最近打算做一个桌面应用程序，然后也打算学一波go语言，所以就借此机会用go写一个带界面的程序。我是用了go-gtk，这里记录一下环境搭建的过程，以及搭建时候踩的四个坑（有坑的地方我着重标出来了）。 一、安装go和设置workspace1.1 安装go如果已经装了go环境的可以直接跳过这一步。 去官网下载页面下载windows版本对应的安装包，或者直接点这里下载1.12.1版本（写这个博客的时候的版本）。 下载完之后就是傻瓜式安装了，打开安装包，接受用户协议、选定安装路径，然后一直点下一步就行了。安装过程会请求管理员权限（用来写入环境变量），同意就行了。 装好之后，打开cmd，输入go version，如果显示如下，说明安装成功： 1.2 设置工作文件夹workspace如果已经设置了workspace的可以直接跳过这一步。 先在某个路径新建一个文件夹，例如我的是D:\\go_workspace（下面都以这个目录为例），作为工作目录。 然后在这个路径下新建三个文件夹，分别命名为bin，pkg，src，作用这里不再赘述。 把D:\\go_workspace目录加入到系统环境变量里去，方法就是在系统变量里面新建一条记录，名称为GOPATH，值为D:\\go_workspace。如果用户变量里面已经存在GOPATH的变量了，那么把这个变量的值也修改为D:\\go_workspace。 打开cmd，输入go env，如果显示如下，说明配置成功： GOPATH就是你的工作目录，GOROOT就是go的安装目录。 二、安装Windows版GTK先贴两个官网，一个是go-gtk在github上的官方项目：链接然后是Windows版GTK的官网：链接 安装方法在两个网站上都有写，愿意的话可以直接去官网看官方教程。官方给WIndows版本的GTK提供了两种安装方法，这里选择其一：使用MSYS2安装。 2.1 安装MSYS2官网 进去就是三个按钮，第一个是32位安装包，第二个是64位安装包，第三个是github链接。 这里选择第二个，下载好后也是傻瓜安装，选定安装目录（我安装的目录是C:\\msys64），一直点下一步就行了。 装好之后开始菜单的MSYS2文件夹里有三个快捷方式： 选择名称里不带32-bit或者64-bit后缀的那个快捷方式打开，就是MSYS2的命令行界面（后面用的都是这个）： 2.2 修改MSYS2的源因为后面要下载的内容都挺大的，如果不换源可能需要下载很久很久。。。 这里换的是清华的源，方法如下。 打开MSYS2的安装目录（我安装的目录是C:\\msys64），进入C:\\msys64\\etc\\pacman.d路径， 编辑mirrorlist.mingw32文件，在开头添加： 1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 编辑mirrorlist.mingw64文件，在开头添加： 1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 编辑mirrorlist.msys文件，在开头添加： 1Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 修改完成后保存，打开MSYS2命令行，输入pacman -Sy，刷新软件包数据即可。 2.3 安装gtk和相关工具安装gtk3： MSYS2命令行输入pacman -S mingw-w64-x86_64-gtk3回车，提示是否进行安装，输入y回车。 安装gtk2： MSYS2命令行输入pacman -S mingw-w64-x86_64-gtk2回车，提示是否进行安装，输入y回车。 安装Glade： MSYS2命令行输入pacman -S mingw-w64-x86_64-glade回车，提示是否进行安装，输入y回车。 安装Devhelp： MSYS2命令行输入pacman -S mingw-w64-x86_64-devhelp回车，提示是否进行安装，输入y回车。 安装build tools： MSYS2命令行输入pacman -S mingw-w64-x86_64-toolchain base-devel回车，提示选择安装哪个库，直接回车，选择全部安装。 2.4 添加msys64环境变量打开环境变量，在系统变量栏的PATH变量中新增两个值，分别是C:\\msys64\\mingw64\\bin和C:\\msys64\\usr\\bin。 两个注意点： ① 注意如果你的安装目录不同请修改成相对应的路径； ② 一定要C:\\msys64\\mingw64\\bin在前，C:\\msys64\\usr\\bin在后，否则会出错！！！！！（（（坑一））） 测试是否成功： 打开cmd命令提示符，输入pkg-config --cflags gtk+-3.0，如果显示如下，说明成功： 继续输入make -v，如果显示如下，说明成功： 三、尝试官方go-gtk的DEMO3.1 编译去github官网下载。 在go工作目录的src文件夹下，新建一个名为github.com的文件夹，然后进入该文件夹，继续新建一个名为mattn的文件夹，然后把下载下来的压缩包解压到mattn文件夹下，并重命名为go-gtk。 最后的目录路径应该是这样的： D:\\go_workspace\\src\\github.com\\mattn\\go-gtk 进入go-gtk\\_example\\demo目录，里面有一个demo.go文件。 打开cmd命令提示符，进入上面所说的demo目录，或者直接在文件夹地址栏里输入cmd即可在当前目录打开命令提示符。输入go build demo.go进行编译，如果像下面没有任何提示，说明编译成功，如果有任何输出，说明报错了。 报错有几种可能，我遇到过两种： ① 报错信息中提示sorry, unimplemented: 64-bit mode not compiled in之类的语句：（（（坑二））） 说明你的mingw版本不对，应该是64位的mingw64，而不是32位的mingw32。出现这种情况有可能是你以前自己安装过mingw而且不是64位版本的，删除32位版本，清理一下注册表系统键值PATH中有关mingw的值，然后重新安装64位版本的（或者重新运行步骤2.3的安装build tools的命令）。 ② 报错信息中提示invalid flag in pkg-config --libs: -Wl,-luuid之类的语句：（（（坑三））） 这是一个大坑，官方的issue里就有很多人讨论这个，这是go语言更新之后的bug，它把-Wl命令参数当成非法参数并禁止执行，你应该自己把这个参数加入whitelist白名单。修改方法如下： 进入C:\\msys64\\mingw64\\lib\\pkgconfig路径，编辑里面的gdk-2.0.pc文件和gdk-win32-2.0.pc文件。两个文件的修改方法相同，把原本在Libs:一行中的-Wl,删除，增加一行LDFLAGS: -Wl。修改后的内容如下： 12345678910111213prefix=/mingw64exec_prefix=$&#123;prefix&#125;libdir=$&#123;exec_prefix&#125;/libincludedir=$&#123;prefix&#125;/includetarget=win32Name: GDKDescription: GTK+ Drawing Kit ($&#123;target&#125; target)Version: 2.24.32Requires: pangowin32 pangocairo gio-2.0 gdk-pixbuf-2.0 cairo-win32Libs: -L$&#123;libdir&#125; -lgdk-$&#123;target&#125;-2.0 -lgdi32 -limm32 -lshell32 -lole32 -luuidCflags: -I$&#123;includedir&#125;/gtk-2.0 -I$&#123;libdir&#125;/gtk-2.0/include LDFLAGS: -Wl 然后继续修改同一个目录下的三个文件：gdk-3.0.pc、gdk-win32-3.0.pc和gdk-broadway-3.0.pc，修改方法相同，也是把原本在Libs:一行中的-Wl,删除，增加一行LDFLAGS: -Wl，修改后的内容如下： 1234567891011121314prefix=/mingw64exec_prefix=$&#123;prefix&#125;libdir=$&#123;exec_prefix&#125;/libincludedir=$&#123;prefix&#125;/includetargets=win32 broadwayName: GDKDescription: GTK+ Drawing KitVersion: 3.24.5Requires: pangowin32 pangocairo gdk-pixbuf-2.0 &gt;= 2.30.0 cairo &gt;= 1.14.0 cairo-gobject &gt;= 1.14.0Requires.private: gio-2.0 &gt;= 2.53.4 cairo-win32 cairo epoxy &gt;= 1.4 fribidi &gt;= 0.19.7Libs: -L$&#123;libdir&#125; -lgdk-3 -lgdi32 -limm32 -lshell32 -lole32 -luuid -lwinmm -ldwmapi -lsetupapi -lcfgmgr32 -lzCflags: -I$&#123;includedir&#125;/gtk-3.0 LDFLAGS: -Wl 保存退出即可。 3.2 运行编译成功后会在demo.go同目录下生成一个demo.exe，双击运行即可。 运行时可能会出现一个问题，这个问题也是有很多人遇到：（（（坑四））） 官方issue链接。 双击exe运行时，弹出对话框提示无法定位程序输入点deflateSetHeader于动态链接库xxx.dll，后面那个xxx.dll有可能不同，但是大部分是zlib1.dll。 出现这种问题时，直接把C:\\msys64\\mingw64\\bin路径下的zlib1.dll文件，复制到C:\\Windows\\System32和C:\\Windows\\SysWOW64文件夹下即可。 如果提示的不是zlib1.dll文件，而是其他dll文件，你也可以试试这个方法（因为我就是报别的dll错，然后用这种方法解决的）。 运行成功之后的界面： 四、相关链接 GitHub的go-gtk官网 go语言官网 Windows版GTK的官网 MSYS2官网 Go版GTK：环境搭建(windows) sorry, unimplemented: 64-bit mode not compiled in解决办法 go编译go-gtk报错 go-gtk/issues/307 windows版的glade安装包下载地址","categories":[{"name":"go","slug":"go","permalink":"https://ultronxr.xyz/categories/go/"}],"tags":[{"name":"go","slug":"go","permalink":"https://ultronxr.xyz/tags/go/"},{"name":"gtk","slug":"gtk","permalink":"https://ultronxr.xyz/tags/gtk/"},{"name":"go-gtk","slug":"go-gtk","permalink":"https://ultronxr.xyz/tags/go-gtk/"}]},{"title":"以当前时间为名新建文件夹并复制文件到其中的bat脚本","slug":"Current-time-for-filename-and-xcopy-in-bat","date":"2019-03-06T07:58:20.000Z","updated":"2019-03-06T09:03:05.999Z","comments":true,"path":"2019/03/06/Current-time-for-filename-and-xcopy-in-bat/","link":"","permalink":"https://ultronxr.xyz/2019/03/06/Current-time-for-filename-and-xcopy-in-bat/","excerpt":"用到了bat脚本中的md命令和xcopy命令。","text":"用到了bat脚本中的md命令和xcopy命令。 一、代码和部分注释注意bat脚本文件需要使用ANSI编码，不要使用UTF8编码，否则包含中文的文件路径会出错！ %date%和%time%两个变量是bat中的系统变量；前者输出当前日期，格式为2019/03/06所示，后者输出当前时间，格式为16:13:23.21（时:分:秒.毫秒）所示，但是如果小时的位置小于10，格式为6:13:23.21（小时的十位变为空格，而不是0）所示。 所以把每一个所需的值截取出来，重新组装即可。 然后是md命令，用于新建文件夹； xcopy用于拷贝文件或文件夹，/E参数作用是复制目录和子目录，包括空目录，/H参数的作用是也复制隐藏文件和系统文件，/V参数作用是验证每个新文件的大小。注意文件夹的路径书写格式，以及反斜杠写法（源文件夹路径最后不要加反斜杠，或者写成\\*.*）。 123456789101112131415161718192021@echo offset \"year=%date:~0,4%\"set \"month=%date:~5,2%\"set \"day=%date:~8,2%\"set \"hour_ten=%time:~0,1%\"set \"hour_one=%time:~1,1%\"set \"minute=%time:~3,2%\"set \"second=%time:~6,2%\"if \"%hour_ten%\" == \" \" ( set \"current_time=%year%-%month%-%day%--0%hour_one%-%minute%-%second%\") else ( set \"current_time=%year%-%month%-%day%--%hour_ten%%hour_one%-%minute%-%second%\")md \"D:\\测试目标文件夹2\\%current_time%\"xcopy /E /H /V \"D:\\测试源文件夹1\\spring_test\" \"D:\\测试目标文件夹2\\%current_time%\\spring_test\\\"xcopy /E /H /V \"D:\\测试源文件夹1\\OMServer_model\" \"D:\\测试目标文件夹2\\%current_time%\\OMServer_model\\\"pause 运行这个bat脚本会输出所复制的所有源文件和文件夹，以及最终复制了多少个文件。如果文件夹名或文件名冲突，会提示是否覆盖。 复制完成后cmd会显示结果如下： 123456789101112............D:\\测试源文件夹1\\OMServer_model\\target\\OMServer_module\\WEB-INF\\lib\\xpp3_min-1.1.4c.jarD:\\测试源文件夹1\\OMServer_model\\target\\OMServer_module\\WEB-INF\\lib\\xstream-1.4.11.1.jarD:\\测试源文件夹1\\OMServer_model\\target\\test-classes\\ApiTest\\ApiTest.htmlD:\\测试源文件夹1\\OMServer_model\\target\\test-classes\\xml\\Status.classD:\\测试源文件夹1\\OMServer_model\\target\\test-classes\\XMLTest\\Bean.classD:\\测试源文件夹1\\OMServer_model\\target\\test-classes\\XMLTest\\test.xmlD:\\测试源文件夹1\\OMServer_model\\target\\test-classes\\XMLTest\\XStreamTest.classD:\\测试源文件夹1\\OMServer_model\\target\\war\\OMServer_module.war复制了 1050 个文件请按任意键继续. . .","categories":[{"name":"bat","slug":"bat","permalink":"https://ultronxr.xyz/categories/bat/"}],"tags":[{"name":"bat","slug":"bat","permalink":"https://ultronxr.xyz/tags/bat/"}]},{"title":"javaweb中的Websocket和Websocket连接池","slug":"Websocket-and-websocketpool-in-javaweb","date":"2019-03-02T10:40:56.000Z","updated":"2019-03-08T06:14:01.548Z","comments":true,"path":"2019/03/02/Websocket-and-websocketpool-in-javaweb/","link":"","permalink":"https://ultronxr.xyz/2019/03/02/Websocket-and-websocketpool-in-javaweb/","excerpt":"WebSocket介绍和一个使用Demo。","text":"WebSocket介绍和一个使用Demo。 一、简介现在为了实现服务器端向网页端同步推送消息，大部分使用的是轮询方式，而轮询方式需要浏览器每隔一个很短的时间定时向服务器发起HTTP请求，服务器返回信息给浏览器。 使用轮询方式进行服务器向客户端推送信息有两个缺点：第一、需要客户端向服务器发送请求，服务器无法直接向客户端发送信息（这也是HTTP的缺点）；第二、如果需要同步的有效信息只有很少的内容但是需要频繁同步，那么HTTP较长的头部则会在资源占用中有很大比重，浪费了带宽资源，或者是频繁的HTTP连接占用了服务器资源。 所以从HTML 5开始，提供了基于TCP连接的WebSocket通信协议，目的在于让单个TCP连接可以进行全双工通信（客户端先和服务器端创建连接，然后一直维持这个连接），减少了多次HTTP通信中重复报头的冗余，让通信更加节省资源。 部分较老版本的浏览器可能不支持websocket，所以在相关代码中需要添加验证该浏览器是否支持websocekt的机制。 二、websocket的URLwebsocket使用ws和wss两种资源标识符（类似于HTTP和HTTPS），wss是建立在安全套接层上的加密连接，所以比普通ws连接更加安全。 ws连接默认使用80端口，wss默认使用443端口。 websocket的URL举例： 12ws://example.com/some/pathwss://example.com/some/path 三、前端使用websocket3.1 建立连接使用以下js代码即可与服务器端建立websocekt连接，获取websocket连接对象： 12//ws_url为服务器指定的websocekt连接地址var websocket = new WebSocket(ws_url); 推荐加入检测浏览器是否支持websocket的代码，改成下面的形式： 1234var websocket = null;if('WebSocket' in window)&#123; var websocket = new WebSocket(ws_url);&#125; 3.2 绑定事件与回调函数websocket对象有四个最主要的事件需要进行绑定，分别是 onopen 、 onmessage 、 onclose 和 onerror ，四个事件分别代表websocekt连接出现 建立连接 、 收到服务器消息 、 关闭连接 和 出现连接错误 四种情况所进行的处理事件。 请注意：回调函数的参数并不是固定的，可以按照实际需要进行增删。 1234567891011121314151617181920212223242526//每个回调函数中的代码是样例//websocket建立连接时，会自动调用该回调函数websocket.onopen = function(evt)&#123; //do something; console.log(\"成功建立websocekt连接。\");&#125;;//websocket客户端接收到来自服务器的消息时，会自动调用该回调函数websocket.onmessage = function(evt)&#123; //do something; console.log(\"收到websocket服务器消息：\" + evt.data);&#125;//websocket连接主动关闭时，会自动调用该回调函数websocket.onclose = function(evt)&#123; //do something; console.log(\"websocket连接关闭！\");&#125;//出现网络问题或者代码层面的bug，会自动调用该回调函数websocket.onerror = function(evt)&#123; //do something; console.log(\"websocekt连接出现错误，连接关闭！\"); websocket.close();&#125; 3.3 向服务器发送信息websocket对象支持直接向服务器发送信息（可以是文本也可是二进制数据），这里发送最简单的文本消息： 1websocket.send(\"你好，websocket服务器！\"); 3.4 主动关闭与服务器的连接1websocket.close(); 四、服务器使用websocket4.1 java依赖包java的websocket服务器有很多选择，这里我使用javax.websocket包，如果项目使用maven框架可以直接添加下面的依赖来获取包： 123456&lt;dependency&gt; &lt;groupId&gt;javax.websocket&lt;/groupId&gt; &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 4.2 新建Endpoint在javax.websocket中，每个websocket连接需要一个Endpoint相对应，Endpoint可以理解成一个单独且完整的websocket连接。 首先需要新建一个Endpoint的类，并添加注解（注解使用方法请看下面的注释）。 12345678910111213141516/* 注解中value的值代表websocket服务器的路径，如果需要参数，可以使用大括号&#123;&#125;传入。 例如这里我的整个项目路径为\"http://localhost:80/project/\" ，这里的value值为\"/wstest\"， 那么前端websocket连接的url应该填写\"ws://localhost:80/project/wstest\"。 如果value值为第二种\"/wstest/&#123;token&#125;\"， 那么前端的websocket连接地址应该在上面的url的基础上再加上\"/&#123;token&#125;\"的内容。 例如\"ws://localhost:80/project/wstest/123456\"，这里的123456会被作为token传入， 如果没有写token，token则等于null。 */@ServerEndpoint(value = \"/wstest\")//@ServerEndpoint(value = \"/wstest/&#123;token&#125;\")public class WSEndpoint&#123;&#125; 4.3 重载四个事件与js的websocket类似，这里的Endpoint也需要对四个事件分别进行相应的绑定。 这里的四个事件分别是 onOpen 、 onMessage 、 onClose 和 onError ，四个事件分别代表websocekt连接出现 建立连接 、 收到客户端消息 、 关闭连接 和 出现连接错误 四种情况所进行的处理事件。 请注意：四个方法的参数并不是固定的，可以按照实际需要进行增删。 1234567891011121314151617181920212223242526272829303132333435363738//四个方法中的代码是样例@ServerEndpoint(value = \"/wstest\")public class WSEndpoint &#123; @OnOpen public void onOpen(Session session) throws IOException &#123; //do something; System.out.println(\"与客户端websocket连接成功。\"); &#125; /* 如果@ServerEndpoint注解中的路径含有token参数传入，请使用下面的onOpen方法 @OnOpen public void onOpen(@PathParam(\"token\") String token, Session session) throws IOException &#123; //do something; &#125; */ @OnMessage public void onMessage(String message, Session session) throws IOException &#123; //do something; System.out.println(\"收到客户端消息：\"+message); &#125; @OnClose public void onClose() throws IOException &#123; //do something; System.out.println(\"与客户端的websocket连接关闭。\"); &#125; @OnError public void onError(Session session, Throwable e) throws IOException &#123; //do something; System.out.println(\"与客户端的websocket连接出现错误，连接关闭！\"); &#125;&#125; 4.4 向客户端发送消息支持直接向客户端发送信息（可以是文本也可是二进制数据），这里发送最简单的文本消息： 1session.getBasicRemote().sendText(\"你好，websocket客户端！\"); 4.5 主动关闭与客户端的连接1session.close(); 五、完整Demo在这个Demo中，我另外添加了websocket连接的token验证、多用户连接、以及使用连接池维护websocket连接的功能。 Demo的运行url是http://localhost:80/project/，ws的连接地址是ws://localhost:80/project/wstest/{token}（也可以另行更改）。 5.1 前端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;strong&gt;&lt;p&gt;websocket demo&lt;/p&gt;&lt;/strong&gt; &lt;br/&gt; &lt;input id=\"text\" type=\"text\" /&gt; &lt;button onclick=\"sendMsg()\"&gt; Send &lt;/button&gt; &lt;button onclick=\"closeWS()\"&gt; Close &lt;/button&gt; &lt;div id=\"message\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; var token = null; //ws会话标识符 var websocket = null; var websocket_url = \"ws://\"+window.location.host+\"/project/wstest\"; if('WebSocket' in window)&#123; token = getToken(); websocket = new WebSocket(websocket_url+\"/\"+token); &#125;else &#123; alert(\"该浏览器不支持websocket！\"); &#125; if(websocket != null)&#123; //连接成功建立的回调方法 websocket.onopen = function(event)&#123; showMsg(\"websocket连接成功，您的token是：\"+token); &#125;; //接收到消息的回调方法 websocket.onmessage = function(event)&#123; if(typeof event.data == \"String\" || typeof event.data == \"string\")&#123; showMsg(\"从服务端接收到消息：\"+event.data); &#125;else&#123; showMsg(\"从服务端收到错误的消息类型：\"+typeof event.data); &#125; &#125;; //连接关闭的回调方法 websocket.onclose = function()&#123; showMsg(\"websocket连接关闭。\"); closeWS(); &#125;; //连接发生错误的回调方法 websocket.onerror = function()&#123; showMsg(\"websocket连接出现错误！\"); closeWS(); &#125;; &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; console.log(\"窗口状态发生变化，websocket连接关闭。\"); closeWS(); &#125;; //依据时间戳获取一个token并简单地混淆 function getToken() &#123; var timestamp = Date.parse(new Date())/1000; return String(timestamp*7+456); &#125; //将消息显示在网页上 function showMsg(msg)&#123; document.getElementById('message').innerHTML += (msg+'&lt;br/&gt;'); &#125; //发送消息 function sendMsg()&#123; var message = document.getElementById('text').value; websocket.send(message); &#125; //关闭连接 function closeWS() &#123; websocket.close(); &#125;&lt;/script&gt;&lt;/html&gt; 5.2 WSEndPoint.java代码（单个ws连接）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import javax.websocket.*;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;import java.io.IOException;/** * WSEndPoint：一个单独且完整的ws连接 * 这整个WSEndPoint都被放在连接池里维护 */@ServerEndpoint(value = \"/wstest/&#123;token&#125;\")public class WSEndpoint &#123; private String token; //当前ws连接的标识 private Session session; //当前ws会话 @OnOpen public void onOpen(@PathParam(\"token\") String token, Session session) throws IOException &#123; this.session = session; this.token = token; WSPool.addWsEndPoint(token, this); session.getBasicRemote().sendText(\"与服务器建立ws连接成功，当前服务器连接池大小：\"+WSPool.getSize()); System.out.println(\"与客户端\"+token+\"建立ws连接，当前服务器连接池大小：\"+WSPool.getSize()); &#125; @OnClose public void onClose() throws IOException &#123; this.session.close(); WSPool.removeWsEndPoint(token); System.out.println(\"websocket连接关闭：\"+token); &#125; @OnMessage public void onMessage(String message, Session session) throws IOException &#123; System.out.println(\"收到用户消息：\"+this.token + \"：\" + message); session.getBasicRemote().sendText(\"服务器已收到你的消息。\"); &#125; @OnError public void onError(Session session, Throwable e) throws IOException &#123; session.close(); WSPool.removeWsEndPoint(token); System.out.println(\"websocket连接错误：\"+this.token); &#125; /* getter and setter */ public String getToken() &#123; return token; &#125; public void setToken(String token) &#123; this.token = token; &#125; public Session getSession() &#123; return session; &#125; public void setSession(Session session) &#123; this.session = session; &#125;&#125; 5.3 WSPool.java代码（连接池）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.io.IOException;import java.util.HashMap;import java.util.Map;/** * websocket连接池 * 用来维护全体ws连接：新增连接、删除连接、向某个连接发送信息等 */public class WSPool &#123; private static Map&lt;String, WSEndpoint&gt; wsPool = new HashMap&lt;&gt;(); private static int size = 0; //添加一个连接进入连接池 public synchronized static void addWsEndPoint(String token, WSEndpoint wsed)&#123; WSPool.wsPool.put(token, wsed); ++size; &#125; //从连接池中删除一个连接 public synchronized static void removeWsEndPoint(String token)&#123; WSPool.wsPool.remove(token); --size; &#125; //获取当前连接池大小 public synchronized static int getWsPoolSize()&#123; return WSPool.size; &#125; //获取一个指定标识的ws连接 public synchronized static WSEndpoint getWsEndPoint(String token)&#123; return WSPool.wsPool.get(token); &#125; //发送信息给指定ws会话 public synchronized static void sendMessageToOneWsEndPoint(String token, String msg)&#123; WSEndpoint wsed = WSPool.wsPool.get(token); if(wsed != null)&#123; try &#123; wsed.getSession().getBasicRemote().sendText(msg); System.out.println(\"向指定ws会话发送信息成功 : \"+token); &#125; catch (IOException e) &#123; //e.printStackTrace(); System.out.println(\"Exception: 无法向指定ws会话发送信息：\"+token); &#125; &#125;else &#123; System.out.println(\"Exception: 不存在指定的ws会话：\"+token); &#125; &#125; /* getter and setter */ public synchronized static Map&lt;String, WSEndpoint&gt; getWsPool() &#123; return wsPool; &#125; public synchronized static void setWsPool(Map&lt;String, WSEndpoint&gt; wsPool) &#123; WSPool.wsPool = wsPool; &#125; public synchronized static int getSize() &#123; return size; &#125; public synchronized static void setSize(int size) &#123; WSPool.size = size; &#125;&#125;","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/categories/javaweb/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/tags/javaweb/"},{"name":"websocket","slug":"websocket","permalink":"https://ultronxr.xyz/tags/websocket/"}]},{"title":"DataTable的ajax用法","slug":"Ajax-usage-of-Datatable","date":"2019-03-02T08:20:32.000Z","updated":"2019-03-02T10:34:25.032Z","comments":true,"path":"2019/03/02/Ajax-usage-of-Datatable/","link":"","permalink":"https://ultronxr.xyz/2019/03/02/Ajax-usage-of-Datatable/","excerpt":"DataTable自带使用ajax获取数据并自动填入表格的功能。","text":"DataTable自带使用ajax获取数据并自动填入表格的功能。 一、简介DataTable作为开源的表格插件，自带分页、实时搜索、自定义排序，以及对于数据源和主题的强大支持，让我们多了一种javaweb表格设计的选择。一般我们都是用ajax从后台获取数据然后用js或者jsp代码填入表格。实际上，DataTable自带使用ajax获取数据并自动填入表格的功能。这里就简单讲解一下这种方法如何使用。 二、使用方法2.1 引用DataTable使用DataTable需要引用两个必不可少的文件，一个是dataTable.js，另一个是dataTable.css，或者是它们的min版本。（当然jquery.js是必不可少的） 这里可以选择使用DataTable中文官网提供的cdn资源： 12http://cdn.datatables.net/1.10.15/css/jquery.dataTables.min.csshttp://cdn.datatables.net/1.10.15/js/jquery.dataTables.min.js 或者直接下载DataTable完整的资源包（该博客撰写时的最新版本为v1.10.15）：官方下载链接DataTables-1.10.15.zip，解压之后找到里面的DataTables-1.10.15\\media\\js\\jquery.dataTables.js文件和DataTables-1.10.15\\media\\css\\jquery.dataTables.css文件（或者它们的min版本），进行引用。（当然也不要忘了jquery.js） 2.2 使用DataTable举例直接讲如何使用DataTable的ajax方法。 编写table代码（这里以一个描述课程信息的表格为例）： 1234567891011121314151617181920&lt;table id=\"courses_table\" style=\"white-space: nowrap;\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;课程编号&lt;/th&gt; &lt;th&gt;课程名称&lt;/th&gt; &lt;th&gt;学院&lt;/th&gt; &lt;th&gt;开课学年&lt;/th&gt; &lt;th&gt;学期&lt;/th&gt; &lt;th&gt;分类&lt;/th&gt; &lt;th&gt;学分&lt;/th&gt; &lt;th&gt;教师&lt;/th&gt; &lt;th&gt;上课时间&lt;/th&gt; &lt;th&gt;上课地点&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt;&lt;/table&gt; classes_table对应的js代码（如有特殊需求，数据的分页过程，可以用后台服务端进行控制，把分好页的数据传给DataTable显示；但是这里没有很多的特殊需求，所以分页交给DataTable自动进行）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546$('#courses_table').DataTable(&#123; scrollX: true, //开启水平滚动 bAutoWidth:true, //自动计算每一列的宽度 bDestroy: true, //在某个元素上覆盖数据时，把前一个元素销毁并重新生成一个 bPaginate: true, //显示翻页按钮 bInfo : true, //显示页脚信息 bScrollCollapse: true, //插件高度自适应 ajax: basePath + \"/get_all_courses\"; //通过ajax获取数据的url columns: [ //指定通过ajax获取的每列数据的来源，这里的json格式为&#123;\"data\":&#123;\"id\":\"xxx\",\"name\":\"xxx\", .......&#125;&#125; &#123;\"data\": \"id\"&#125;, &#123;\"data\": \"name\"&#125;, &#123;\"data\": \"institute\"&#125;, &#123;\"data\": \"school_year\"&#125;, &#123;\"data\": \"semester\"&#125;, &#123;\"data\": \"category\"&#125;, &#123;\"data\": \"credit\"&#125;, &#123;\"data\": \"teacher\"&#125;, &#123;\"data\": \"class_time\"&#125;, &#123;\"data\": \"class_place\"&#125; ], language: &#123; //设置语言（不设置的话是默认英文）：自定义工具栏显示的内容 oPaginate: &#123; sFirst: \"首页\", sPrevious: \"上一页\", sNext: \"下一页\", sLast: \"尾页\" &#125;, sSearch: \"搜索\", sInfoEmpty: \"当前显示第 0 至 0 项，共 0 项\", sInfo: \"当前显示第 _START_ 至 _END_ 项，共 _TOTAL_ 项\", sLengthMenu: \"每页 _MENU_ 项\", &#125;, columnDefs: [&#123; //设置列定义初始化属性 targets: 10, //指定初始化的列号（index从左侧0开始） data: \"null\", //不指定数据 render: //渲染/操作从数据源读取到的数据 function (data, type, row) &#123; //data是对应当前格子的值，row是对应当前行中的所有格的值 var id = row.id; var year = row.school_year; var semester = row.semester; var html = \"&lt;a href='javascript:void(0);' onclick='getcourseinfo(\"+id+\",\\\"\"+year+\"\\\",\"+semester+\")' class='table_a' &gt;查看&lt;/a&gt;\"; return html; //把指定格设置为超链接a标签，按下的动作为getcourseinfo()函数的操作 &#125; &#125;]&#125;); 然后是后台的发送数据的java代码，直接用PrintWriter返回json格式的字符串（用的是阿里的fastjson）： 12345678910111213141516171819protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; List&lt;Course&gt; courseList = docDao.getCourseList(); JSONArray array = JSONArray.parseArray(JSON.toJSONString(courseList)); JSONObject json = new JSONObject(); json.put(\"data\", array); //System.out.println(json.toJSONString()); pwoutput(response, json);&#125;private void pwoutput(HttpServletResponse response,JSONObject json) throws IOException &#123; response.setCharacterEncoding(\"UTF-8\"); response.setDateHeader(\"Expires\", 0); response.setHeader(\"Cache-Control\", \"no-cache\"); response.setHeader(\"Pragma\", \"no-cache\"); PrintWriter pw = response.getWriter(); pw.println(json.toJSONString()); pw.flush(); pw.close();&#125; 最后是结果，可以看到前端的表格如图（css这里没有贴，样式怎么调能好看还是得自己试）（数据都是编的）：","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/categories/javaweb/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/tags/javaweb/"},{"name":"datatable","slug":"datatable","permalink":"https://ultronxr.xyz/tags/datatable/"},{"name":"js","slug":"js","permalink":"https://ultronxr.xyz/tags/js/"},{"name":"jsp","slug":"jsp","permalink":"https://ultronxr.xyz/tags/jsp/"}]},{"title":"Ubuntu 16.04 LTS 完整安装docker和docker-compose以及常用命令","slug":"Docker-with-compose-installation-in-Ubuntu","date":"2019-03-01T08:59:09.000Z","updated":"2019-03-01T10:06:06.716Z","comments":true,"path":"2019/03/01/Docker-with-compose-installation-in-Ubuntu/","link":"","permalink":"https://ultronxr.xyz/2019/03/01/Docker-with-compose-installation-in-Ubuntu/","excerpt":"Ubuntu 16.04 LTS 完整安装docker和docker-compose以及常用命令","text":"Ubuntu 16.04 LTS 完整安装docker和docker-compose以及常用命令 一、安装docker这里使用root用户安装docker，后面会对docker进行配置，使其能让所有用户使用。 1.1 安装apt-transport-https包目的是让apt可以通过HTTPS使用安装包的仓库，命令如下： 1sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common 1.2、添加Docker官方的GPG密钥GPG密钥就是一种加密方法，加密之后保证你从docker库中获取的镜像和安装包等是经过官方验证的。 1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 安装完成后bash会显示所安装的密钥，请确保密钥的最后八个字符串与下面的完全相同： 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 1.3、设置docker的stable库设置docker的设置stable存储库，设置完成后更新apt的索引。 12345sudo apt-key fingerprint 0EBFCD88sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"sudo apt-get update 1.4、安装docker-ce下面这条命令默认安装最新版本的docker-ce： 1sudo apt-get install -y docker-ce 如果需要指定版本的docker-ce，需要使用下面的命令，第一条是列出可用版本，第二条命令是指定安装版本（把&lt;version&gt;的位置替换成指定版本）： 123apt-cache madison docker-cesudo apt-get install docker-ce=&lt;VERSION&gt; 二、验证docker是否安装完成查看docker服务是否启动： 1systemctl status docker 如果没有启动，使用以下命令启动docker： 1sudo systemctl start docker docker服务如果已经启动，可以运行hello-world镜像来验证docker正确运行： 1sudo docker run hello-world 三、设置docker可以被非root用户直接使用比如你现在以非root身份登录系统，每次运行docker命令都需要加sudo，为了避免这个，可以把当前用户加入docker用户组。 下面是操作过程（非root用户登录系统）： 3.1 创建docker用户组（新版docker在安装时会自动创建docker用户组，如果运行下面的命令，提示docker用户组已存在，可以直接进入下一步） 1sudo groupadd docker 3.2 将当前用户加入docker用户组1sudo gpasswd -a $&#123;USER&#125; docker 3.3 重启docker服务1sudo systemctl restart docker 3.4 用户退出登录，重新登录（别忘了这一步！）完成后非root用户也可以直接运行docker的相关命令，而不需要加sudo。 四、安装docker-compose很简单，一条命令，只不过需要先按照python3的环境（这是我所有找到能安装docker-compose最方便的方法了）： 1sudo pip3 install docker-compose 五、docker常用命令 作用 命令 参数含义 登录docker docker login 无 查看当前正在运行的所有镜像 docker ps 无 查看当前正在运行的所有镜像的id docker ps -q 无 查看所有镜像 docker ps -a 无 查找镜像 docker search &lt;image&gt; image：镜像名称 下载镜像 docker pull &lt;image&gt; image：镜像名称 后台守护式运行镜像 docker run -d &lt;image&gt; image：镜像名称 运行镜像的同时进入交互界面 docker run -it &lt;image&gt; /bin/bash image：镜像名称 运行镜像的同时设置环境变量 docker -e &lt;name&gt;=&lt;value&gt; &lt;image&gt; name：环境变量名称，value：环境变量的值，image：镜像名称 运行的时候进行端口映射 docker run -p &lt;hostport&gt;:&lt;containerport&gt; hostport：主机端口，containerport：容器端口 运行容器的时候指定容器名称 docker run --name &lt;name&gt; name：所指定的容器的名称 运行容器的时候指定重启策略 docker run --restart=&lt;val&gt; val：restart策略的值，可选always和on-failure等值 进入正在运行的镜像 docker exec -it &lt;containerid&gt; /bin/bash containerid：容器id 停止运行容器 docker stop &lt;containerid&gt; containerid：容器id 删除容器 docker rm &lt;containerid&gt; containerid：容器id 注：以上表格中的尖括号&lt;&gt;所括的内容为必选参数，运行命令时必须替换成实际内容。","categories":[{"name":"docker","slug":"docker","permalink":"https://ultronxr.xyz/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ultronxr.xyz/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"}]},{"title":"使用docker中的Netcloud镜像搭建你的个人网盘","slug":"Build-your-personal-netdisk-using-the-Netcloud-image-in-docker","date":"2019-03-01T08:52:56.000Z","updated":"2019-03-01T10:53:25.473Z","comments":true,"path":"2019/03/01/Build-your-personal-netdisk-using-the-Netcloud-image-in-docker/","link":"","permalink":"https://ultronxr.xyz/2019/03/01/Build-your-personal-netdisk-using-the-Netcloud-image-in-docker/","excerpt":"简单介绍一下通过docker的nextcloud镜像搭建个人网盘。","text":"简单介绍一下通过docker的nextcloud镜像搭建个人网盘。 一、简介现在国内市面上有很多网盘，比如百度网盘和腾讯微云，但是基本上都是限速，然后要充钱才能获取更好的服务。 这里简单介绍一下通过docker的nextcloud镜像搭建个人网盘，网盘的传输速度取决于服务器的网络带宽。而且nextcloud可以更深层次地设置和定制自己需要的功能，或者对网盘进行监控和优化等操作。也可以给其他人分配子账户和指定用户组，进行方便的管理。总之功能比那些市面上的网盘功能多很多。 或者也可以使用现在阿里云提供的不限速的OSS系统作为网盘（但是这个不适合放很多很多文件），后面我应该会介绍到这个系统的使用方法。 二、安装2.1 安装docker安装方法详见我的博客另一篇文章：Ubuntu 16.04 LTS 完整安装docker和docker-compose以及常用命令 2.2 安装nextcloud镜像并运行找到镜像然后下载下来，注意下载的时候请选择OFFICIAL官方的镜像。 12345docker search nextclouddocker pull nextclouddocker run -d --restart=always --name nextcloud -p 80:80 -v /root/nextcloud:/data nextcloud 第三条命令的-d代表该容器为守护容器，会在后台运行，--restart=always表示无论如何改容器都会被自动重启，--name nextcloud表示把容器的名称命名为nextcloud，-p 80:80表示把容器的80端口映射到主机的80端口（前一个是主机端口，后一个是容器端口），-v /root/nextcloud:/data表示把主机的/root/nextcloud目录映射到容器中的/data目录。 2.3 检查镜像是否运行成功1docker ps 找到nextcloud对应的镜像，在PORTS那一列查看值，如果显示的是0.0.0.0:80-&gt;80/tcp说明端口映射成功。 如果镜像没有在运行，或者显示的端口值不正确，有可能是主机的80端口已经被占用，可以清理一下占用80端口的进程，或者选择不映射到80端口。然后重新尝试运行。 2.4 登录nextcloud界面并进行初始化设置在浏览器输入服务器的公网ip加端口（如果是80端口不用写），即可进入nextcloud登录界面。 第一次进入nextcloud，它会要求你设置管理员账户，数据存放目录，以及数据库配置。 管理员账户填完后，数据存放目录可以保持默认，数据库配置也可以保持默认（如果网盘存放大量数据，推荐使用mysql，否则使用默认的sqlite即可）。 点击安装完成，nextcloud就会应用设置，稍等一会就可以进入网盘的主界面了。 2.5 设置管理员账户的联系邮箱设置邮箱后，你的网盘就会在指定的情况下给你发邮件提醒你了。设置方法如下： （重要！）需要打开你的邮箱的SMTP功能，在邮箱的设置界面可以找到。 进入nextcloud的设置界面，找到基本设置，在电子邮件服务器下面对应位置填写以下信息： 123456789发送模式：SMTP 加密：SSL/TLS来自地址：你的邮箱地址认证方法： 登录 勾选需要认证服务器地址：你使用邮箱公司所使用的SMTP的IP地址和端口（一般在官网可以查到）凭证：账户名和密码 设置完成后点击测试发送邮件，如果你的邮箱能收到nextcloud的邮件说明配置成功。","categories":[{"name":"docker","slug":"docker","permalink":"https://ultronxr.xyz/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ultronxr.xyz/tags/docker/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"netdisk","slug":"netdisk","permalink":"https://ultronxr.xyz/tags/netdisk/"}]},{"title":"Java项目的Utils包中一些常用的通用静态函数","slug":"Functions-commonly-used-in-Java-Utils-packages","date":"2019-02-22T12:42:22.000Z","updated":"2019-02-22T13:27:20.980Z","comments":true,"path":"2019/02/22/Functions-commonly-used-in-Java-Utils-packages/","link":"","permalink":"https://ultronxr.xyz/2019/02/22/Functions-commonly-used-in-Java-Utils-packages/","excerpt":"记录一些例如JDBCUtil、获取随机整数、MD5加密等常用的Utils函数。","text":"记录一些例如JDBCUtil、获取随机整数、MD5加密等常用的Utils函数。 一、JDBCUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;public class JDBCUtil &#123; private static String jdbcDriver = null; private static String url = null; private static String username = null; private static String password = null; static &#123; loadProperties(); try &#123; Class.forName(jdbcDriver); &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"[x] ClassNotFoundException 数据库加载驱动失败！\"); e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection con = null; try &#123; con = DriverManager.getConnection(url, username, password); &#125; catch (SQLException e) &#123; System.out.println(\"[x] SQLException 数据库连接失败！\"); e.printStackTrace(); &#125; return con; &#125; public static void closeConnection(ResultSet rs, PreparedStatement stmt, Connection con) &#123; try &#123; if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; System.out.println(\"[x] SQLException 关闭JDBC连接的RS时出错！\"); //e.printStackTrace(); &#125; try &#123; if (stmt != null) stmt.close(); &#125; catch (SQLException e) &#123; System.out.println(\"[x] SQLException 关闭JDBC连接的STMT时出错！\"); //e.printStackTrace(); &#125; try &#123; if (con != null) con.close(); &#125; catch (SQLException e) &#123; System.out.println(\"[x] SQLException 关闭JDBC连接的CON时出错！\"); //e.printStackTrace(); &#125; &#125; private static void loadProperties() &#123; InputStream inputStream = JDBCUtil.class.getClassLoader().getResourceAsStream( \"jdbc.properties\" ); Properties p = new Properties(); try&#123; p.load(inputStream); &#125;catch(IOException e)&#123; System.out.println(\"[x] IOException JDBC配置文件加载失败！\"); //e.printStackTrace(); &#125; jdbcDriver = p.getProperty(\"driverClassName\"); url = p.getProperty(\"url\"); username = p.getProperty(\"username\"); password = p.getProperty(\"password\"); &#125;&#125;/* jdbc.propertiesdriverClassName=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8username=password= */ 二、获取随机整数12345678910/** * 获取随机整数 * @param min 所需要整数范围的最小值 * @param max 所需要整数范围的最大值 * @return int 一个整数，范围为两边闭合的区间[min,max] */private static Random random = new Random();public static int intRangedRandNum(int min, int max) &#123; return random.nextInt(max)%(max-min+1)+min;&#125; 三、MD5加密123456789101112131415/** * 对字符串进行MD5加密 * @param data 需要加密的目标字符串 * @return String 返回加密后的结果字符串，长度为32且全部小写 */public static String toMD5(String data) &#123; if (data == null) return null; try &#123; MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(data.getBytes()); return new BigInteger(1, md.digest()).toString(16); &#125; catch (NoSuchAlgorithmException e) &#123; return null; &#125;&#125; 四、判断一个字符是否是中文汉字和中文标点1234567891011121314151617181920212223242526/** * 判断一个字符是否是汉字（中文标点不算），汉字的编码范围：[\\u4e00-\\u9fa5] * @param c 所需要判断的字符 * @return boolean 判断的结果，是汉字为true，不是为false */public static boolean isChineseCharacter(char c) &#123; return String.valueOf(c).matches(\"[\\u4e00-\\u9fa5]\");&#125;/** * 判断一个字符是否为中文标点符号 * @param c 所需要判断的字符 * @return boolean 判断的结果，是中文标点为true，不是为false */public static boolean isChinesePunctuation(char c) &#123; Character.UnicodeBlock ub = Character.UnicodeBlock.of(c); if (ub == Character.UnicodeBlock.GENERAL_PUNCTUATION || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_FORMS || ub == Character.UnicodeBlock.VERTICAL_FORMS) &#123; return true; &#125; else &#123; return false; &#125;&#125; 五、计算数学表达式(字符串)的值(Jeval)12345678910111213141516171819202122232425/** * 计算数学表达式(字符串)的值，使用Jeval * @param expression 待计算的字符串类型的数学表达式 * @return String 计算的结果(PlainString表示取消了大数的科学计数法) */private static Evaluator evaluator = new Evaluator();public static String getAnsOfAExpression(String expression)&#123; Double res = 0.0; BigDecimal bigDecimal = null; try&#123; res = evaluator.getNumberResult(expression); bigDecimal = new BigDecimal(res.toString()); &#125;catch (EvaluationException e) &#123; e.printStackTrace(); &#125; return bigDecimal.toPlainString();&#125;/*maven 包依赖&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jeval&lt;/groupId&gt; &lt;artifactId&gt;jeval&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt;&lt;/dependency&gt; */","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"}]},{"title":"Win10的睡眠和休眠","slug":"Win10-sleep-and-hibernation","date":"2019-01-30T01:54:14.000Z","updated":"2019-01-31T13:47:37.789Z","comments":true,"path":"2019/01/30/Win10-sleep-and-hibernation/","link":"","permalink":"https://ultronxr.xyz/2019/01/30/Win10-sleep-and-hibernation/","excerpt":"这是强迫症的Win10整顿计划系列的第一篇，这个系列主要记录一些Win10的系统设置，或者关闭一些不必要的功能，或是几个好用的软件，能让win10更便于工作和学习。这个开坑第一篇，先讲讲Windows的睡眠和休眠。","text":"这是强迫症的Win10整顿计划系列的第一篇，这个系列主要记录一些Win10的系统设置，或者关闭一些不必要的功能，或是几个好用的软件，能让win10更便于工作和学习。这个开坑第一篇，先讲讲Windows的睡眠和休眠。 一、睡眠sleep和休眠hibernateWin10有一个功能是睡眠（台式机和笔记本都有），另一个是休眠（笔记本特有），两者都能暂停工作、“关闭电脑”，并且重新打开电脑后能恢复工作进度。两者功能相同但是存在区别，这里简单描述一下两者的区别以及如何关闭这两个功能。 非常简洁地表述两者的联系和区别： 123睡眠实际上没有关闭电脑，休眠是完全关闭电脑了，但是两者在重新打开电脑后都能恢复原来的工作状态；睡眠能比休眠更快地唤醒电脑；睡眠的系统工作内容还是保存在内存中，所以没有完全断电，休眠则是保存在硬盘上，所以是完全断电； 下面是比较具体的说明： 12345睡眠模式下，系统会给内存保持通电，其他硬件断电（实际上不是绝对的），从而保留当前的工作状态。在下次开机时，可以非常快速地直接进入系统，而不用经过系统的预加载过程。所以睡眠模式时不能让电脑的电源出现问题或者断电，否则会导致工作状态丢失或数据丢失。休眠模式下，系统会把内存中的内容转化成休眠文件，保存在系统盘的预留位置内（hiberfil.sys文件，大小等于实际内存大小），然后给所有设备断电。在下次开机时，系统会读取休眠文件并恢复到内存中，从而恢复工作状态。过程其实相当于关机重启，所以速度不快。休眠模式下可以断电。 二、关闭睡眠功能这么好的功能为什么要关？？？是因为不知道为什么，我的笔记本每次睡眠之后就唤醒不了，都只能强制断电重启！！！ 这里说的关闭其实并不算是关闭，只能阻止系统进入睡眠状态。 取消睡眠的方法： ① 开始菜单——设置——系统——电源和睡眠：把睡眠下面的两个“在使用xx情况下，电脑在经过以下时间后进入睡眠状态”下拉选项都设置成“从不”。 或 ② 控制面板——系统和安全——电源选项：中间的选定的计划，选择当前的计划（一般是平衡），右侧的 更改计划设置 按钮，把“使计算机进入睡眠状态”一行的两个下拉选项都设置成“从不”。 不仅要把你关了，而且不想再见到你了——去掉开始菜单电源按钮中的睡眠选项： 控制面板——系统和安全——电源选项：左侧的选择电源按钮的功能，进去之后点一下带有管理员符号的更改当前不可用的设置，最下面的关机设置里的复选框就可以改动了，把睡眠 显示在开始菜单中的复选框勾勾去掉，然后最下面保存修改即可。 三、关闭休眠功能这是确确实实可以关闭的功能，同时关闭之后，系统盘中的保存休眠文件的位置就会自动删除，就是那个hiberfil.sys文件，然后系统盘就会多出一些空位置。 关闭方法： 管理员模式的cmd命令行——powercfg -h off 收工。 想要重新打开休眠功能的话就把off改成on：powercfg -h on，另外powercfg -a可以查看系统的所有睡眠状态。 去掉开始菜单电源按钮中的休眠选项： 关闭休眠功能后，休眠选项会自动删除，如果不关闭只想隐藏休眠选项的话，还是和去掉睡眠选项一样： 控制面板——系统和安全——电源选项：左侧的选择电源按钮的功能，进去之后点一下带有管理员符号的更改当前不可用的设置，最下面的关机设置里的复选框就可以改动了，把休眠 显示在开始菜单中的复选框勾勾去掉，然后最下面保存修改即可（如果关闭了休眠功能这里是没有休眠的复选框的！）。 四、特殊的“混合睡眠”模式Windows还给台式机加了一种另外的特殊模式：混合睡眠模式。 顾名思义，就是把睡眠和休眠同时进行，既保持内存不断电，同时也把内存中的工作内容保存为休眠文件放到磁盘上。这样做既可以保证迅速恢复电脑工作状态，也防止了出现电源异常或断电的情况时数据丢失。 五、参考资料 windows10/7关闭休眠，怎么删除hiberfil.sys 睡死的Win10？那是你没用对","categories":[{"name":"强迫症的Win10整顿计划","slug":"强迫症的Win10整顿计划","permalink":"https://ultronxr.xyz/categories/强迫症的Win10整顿计划/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://ultronxr.xyz/tags/win10/"},{"name":"windows","slug":"windows","permalink":"https://ultronxr.xyz/tags/windows/"}]},{"title":"SSD接口","slug":"Different-SSD-Interface","date":"2019-01-29T11:32:50.000Z","updated":"2019-02-28T05:57:04.907Z","comments":true,"path":"2019/01/29/Different-SSD-Interface/","link":"","permalink":"https://ultronxr.xyz/2019/01/29/Different-SSD-Interface/","excerpt":"SSD接口介绍。","text":"SSD接口介绍。 一、接口与协议我们常说的SATA、M.2、PCIe等等指的都是物理接口，而AHCI、ATA、NVMe等所指的则是控制硬盘的协议，协议中又包含逻辑协议（AHCI、NVMe）和指令协议（ATA、NVMe），这里不详细展开。 二、接口主流SSD接口主要就有SATA、M.2这两种，其他的mSATA、SATA Express、PCIe、U.2、SAS等接口都有受众，但确实不是非常流行。所以这里主要讲前面两种接口。 2.1 SATA接口SATA接口（Serial ATA，Serial Advanced Technology Attachment，串行ATA）是目前大部分硬盘最常用的接口，走的是，从1代发展到现在3代，传输速率大幅提升。 但是对于发展缓慢的机械硬盘HDD来说，SATA 3.0的传输速率远大于HDD的读写速率，所以HDD用SATA是非常够用的了。而2.5英寸的普通SSD也没有过大的读写速率需求，SATA接口足够使用。 下面是SATA三个主要版本的带宽、传输速率对照表： SATA版本 带宽 Gb/s 理论传输速率 MB/s SATA 3.0 6 600 SATA 2.0 3 300 SATA 1.0 1.5 150 带宽是指每秒能发送或者接收多少位（bit）的数据，而在SATA编码中，每10位数据有8位是实际数据，2位是校验数据，所以这种编码方式称为8/10编码； 理论传输速率是指每秒能发送或接收多少字节（Byte）的实际数据，计算方式为 理论传输速率MB/s = 带宽Gb/s * 0.8（8/10编码） / 8（每字节8位）。 2.2 M.2接口M.2接口（前身为Next Generation Form Factor (NGFF)）现在主要有两种类型，B Key（socket 2） 和 M Key（socket 3） 。前者走SATA 3.0或者PCIe 2.0 x4通道，理论传输速率为600MB/s左右；后者走PCIe 3.0 x4通道，理论传输速率则高达4GB/s。 M Key（socket 3）因为传输速率很高，需要足够的稳定性，所以NVMe协议的M.2接口正逐步取代以前使用的AHCI协议M.2接口。 所以M.2的socket 2、3速率差距这么大，如何区分这两者？ 看防呆口的位置。 防呆口在接口左边，且短的一边为6个针脚，为B Key；防呆口在右边，且短的一边为5个针脚，为M Key。见下图： 再看SSD，把SSD正面（有存储芯片的一面）朝上，左侧有缺口的是B Key，右侧有缺口的是M Key。 B+M Key的SSD可以插在两种M.2接口上，而只有单独一边缺口的SSD（单独B Key或单独M Key）只能插在对应的接口上。 不看SSD型号，单看接口形状的情况下，如果SSD只支持M Key，说明这个SSD一定走PCIe 3.0通道，传输速率相当高；如果支持B+M Key，则无法判断是走SATA还是走PCIe，需要通过SSD型号来判断；如果只有B Key（暂时还没见过这种的SSD），则一定走SATA 3.0通道或PCIe 2.0，传输速率不是非常高。 三、参考资料 维基百科PCI-E 维基百科SATA 维基百科M.2 SSD升级选购全攻略 M.2 SSD 選購指南","categories":[{"name":"硬件知识","slug":"硬件知识","permalink":"https://ultronxr.xyz/categories/硬件知识/"}],"tags":[{"name":"SSD","slug":"SSD","permalink":"https://ultronxr.xyz/tags/SSD/"}]},{"title":"使用XStream处理XML文档/数据","slug":"Process-XML-text-using-XStream","date":"2019-01-24T08:17:08.000Z","updated":"2019-01-24T14:30:19.331Z","comments":true,"path":"2019/01/24/Process-XML-text-using-XStream/","link":"","permalink":"https://ultronxr.xyz/2019/01/24/Process-XML-text-using-XStream/","excerpt":"Java里解析XML数据的API很多，主要是4种：DOM、SAX、JDOM、DOM4J。最近项目里用到了XStream，用来相互转化Java Bean和XML。这篇博客旨在快速上手使用XStream，来对XML数据和Java对象互相转化，而不是详细介绍，详细介绍请参看文章末尾官方文档的链接。","text":"Java里解析XML数据的API很多，主要是4种：DOM、SAX、JDOM、DOM4J。最近项目里用到了XStream，用来相互转化Java Bean和XML。这篇博客旨在快速上手使用XStream，来对XML数据和Java对象互相转化，而不是详细介绍，详细介绍请参看文章末尾官方文档的链接。 一、包在maven的pom.xml文件里面加上依赖（写这篇博客时，这里的版本是最新的）： 12345&lt;dependency&gt; &lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt; &lt;artifactId&gt;xstream&lt;/artifactId&gt; &lt;version&gt;1.4.11.1&lt;/version&gt;&lt;/dependency&gt; 二、使用方法1、初始化一个XStream对象123XStream xstream = new XStream();XStream xstream = new XStream(new DomDriver()); // does not require XPP3 libraryXStream xstream = new XStream(new StaxDriver()); // does not require XPP3 library starting with Java 6 有三种初始化的方法，第一种是默认方法，使用XPP3解析器，需要依赖xstream-[version].jar, xpp3-[version].jar and xmlpull-[version].jar三个包。下面两种是指定官方DOM解析器或使用Java6集成的Stax解析器。 这里我选择使用第三种。 2、设置依赖模式1234567891011//默认依赖模式xstream.setMode(XStream.XPATH_RELATIVE_REFERENCES); //特殊依赖模式xstream.setMode(XStream.XPATH_ABSOLUTE_REFERENCES);xstream.setMode(XStream.SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES);xstream.setMode(XStream.SINGLE_NODE_XPATH_RELATIVE_REFERENCES);xstream.setMode(XStream.ID_REFERENCES);//无依赖xstream.setMode(XStream.NO_REFERENCES); 指定模式后，XStream在把Java对象转成XML时，会在XML中加上每个元素的依赖是什么，例如下面的XML中，最后一个cd元素的reference属性和最后一个list元素的reference属性就是在XPATH_ABSOLUTE_REFERENCES模式下自动生成的。 12345678910&lt;list&gt; &lt;cd&gt; &lt;id&gt;maria rita&lt;/id&gt; &lt;/cd&gt; &lt;cd&gt; &lt;id&gt;basement_jaxx_singles&lt;/id&gt; &lt;/cd&gt; &lt;cd reference=\"/list/cd[2]\"/&gt; &lt;list reference=\"/list\"/&gt;&lt;/list&gt; 没有特殊需求的话，这里选用最后一种，不指定依赖NO_REFERENCES。 3、给Java Bean添加注解看下面的三个Bean：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@XStreamAlias(\"ExtensionPhone\")public class Ext &#123; @XStreamAlias(\"PhoneID\") @XStreamAsAttribute private String id; @XStreamAlias(\"PhoneName\") @XStreamAsAttribute private String name; //构造函数和getter、setter省略 @Override public String toString() &#123; return \"Ext&#123;\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125;@XStreamAlias(\"IncomingPhoneCall\")public class Visitor &#123; @XStreamAlias(\"PhoneCallID\") @XStreamAsAttribute private String id; @XStreamAlias(\"PhoneCallerID\") @XStreamAsAttribute private String from; @XStreamAlias(\"PhoneCalledID\") @XStreamAsAttribute private String to; @XStreamAlias(\"ExtensionPhone\") private Ext ext; @XStreamAlias(\"State\") private String state; //构造函数和getter、setter省略 @Override public String toString() &#123; return \"Visitor&#123;\" + \"id='\" + id + '\\'' + \", from='\" + from + '\\'' + \", to='\" + to + '\\'' + \", ext=\" + ext + \", state='\" + state + '\\'' + '&#125;'; &#125;&#125;@XStreamAlias(\"Status\")public class Status &#123; @XStreamAlias(\"IncomingPhoneCall\") private Visitor visitor; //构造函数和getter、setter省略 @Override public String toString() &#123; return \"Status&#123;\" + \"visitor=\" + visitor + '&#125;'; &#125;&#125; 上面的三个Bean中出现了两种注解，即@XStreamAlias(&quot;&quot;)和@XStreamAsAttribute，这两种是最常用的注解，前者的作用是给成员变量设置别名，后者表示把该成员变量设置为属性，而不是一个独立元素。 常用注解如下： 123456@XStreamAlias(&quot;&quot;) 设置字段别名@XStreamAsAttribute 设置字段为父元素属性，而不是独立元素@XStreamOmitField 忽略此字段（省略此成员变量，不加入XML中）@XStreamImplicit 隐式集合（忽略根元素）@XStreamImplicit(itemFieldName=&quot;&quot;) 设置隐式集合中的元素名称@XStreamConverter(&quot;&quot;) 自定义转换器 4.应用注解应用注解的方法有两种，第一种是让解析器自动探测注解，第二种是指定使用哪个类的注解。两者的区别，在于性能上，前者需要对每一个类都进行缓存，而后者只需要对指定的类进行缓存。 12xstream.autodetectAnnotations(true); //自动探测注解xstream.processAnnotations(Class[] type); //指定使用哪个类的注解 5.Java Bean转XML先看Java Bean转XML： 1234567891011121314//构造Java BeanExt ext = new Ext(\"1001\", \"Ext1001\");Visitor visitor = new Visitor(\"0001\", \"123000000\", \"456000000\", ext, \"processing\");Status status = new Status(visitor);//初始化xstreamXStream xstream = new XStream(new StaxDriver());xstream.setMode(XStream.NO_REFERENCES);xstream.processAnnotations(Status.class);//Bean转XMLString res = xstream.toXML(status);System.out.println(res); 查看输出结果（经过格式化）： 1234567&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;Status&gt; &lt;IncomingPhoneCall PhoneCallID=\"0001\" PhoneCallerID=\"123000000\" PhoneCalledID=\"456000000\"&gt; &lt;ExtensionPhone PhoneID=\"1001\" PhoneName=\"Ext1001\"/&gt; &lt;State&gt;processing&lt;/State&gt; &lt;/IncomingPhoneCall&gt;&lt;/Status&gt; 6、XML转Java Bean12Status status1 = (Status)xstream.fromXML(res);System.out.println(status1); 输出结果：1Status&#123;visitor=Visitor&#123;id=&apos;0001&apos;, from=&apos;123000000&apos;, to=&apos;456000000&apos;, ext=Ext&#123;id=&apos;1001&apos;, name=&apos;Ext1001&apos;&#125;, state=&apos;processing&apos;&#125;&#125; 三、相关资料 官方文档 XStream使用详解","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"xml","slug":"xml","permalink":"https://ultronxr.xyz/tags/xml/"}]},{"title":"直接打印Java对象的内存地址","slug":"Print-address-of-object-in-java","date":"2019-01-20T07:31:11.000Z","updated":"2019-01-24T08:20:16.509Z","comments":true,"path":"2019/01/20/Print-address-of-object-in-java/","link":"","permalink":"https://ultronxr.xyz/2019/01/20/Print-address-of-object-in-java/","excerpt":"记录一下用Java直接打印对象的地址的代码，也可以使用调试的方法查看对象地址，这里就单纯记录一下。 从别人的博客看到的：原博客","text":"记录一下用Java直接打印对象的地址的代码，也可以使用调试的方法查看对象地址，这里就单纯记录一下。 从别人的博客看到的：原博客 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import sun.misc.Unsafe;import java.lang.reflect.Field;public class PrintAddress &#123; static final Unsafe unsafe = getUnsafe(); static final boolean is64bit = true; public static void main(String []args)&#123; Integer a = Integer.valueOf(\"1\"); printAddresses(\"a\", a); &#125; public static void printAddresses(String label, Object... objects) &#123; System.out.print(label + \": 0x\"); long last = 0; int offset = unsafe.arrayBaseOffset(objects.getClass()); int scale = unsafe.arrayIndexScale(objects.getClass()); switch (scale) &#123; case 4: long factor = is64bit ? 8 : 1; final long i1 = (unsafe.getInt(objects, offset) &amp; 0xFFFFFFFFL) * factor; System.out.print(Long.toHexString(i1)); last = i1; for (int i = 1; i &lt; objects.length; i++) &#123; final long i2 = (unsafe.getInt(objects, offset + i * 4) &amp; 0xFFFFFFFFL) * factor; if (i2 &gt; last) System.out.print(\", +\" + Long.toHexString(i2 - last)); else System.out.print(\", -\" + Long.toHexString( last - i2)); last = i2; &#125; break; case 8: throw new AssertionError(\"Not supported\"); &#125; System.out.println(); &#125; private static Unsafe getUnsafe() &#123; try &#123; Field theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\"); theUnsafe.setAccessible(true); return (Unsafe) theUnsafe.get(null); &#125; catch (Exception e) &#123; throw new AssertionError(e); &#125; &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"}]},{"title":"Java中 parseInt 和 valueOf 两种方法的比较","slug":"The-Comparison-of-parseInt-and-valueOf-in-java","date":"2019-01-19T09:06:57.000Z","updated":"2019-01-24T08:19:42.842Z","comments":true,"path":"2019/01/19/The-Comparison-of-parseInt-and-valueOf-in-java/","link":"","permalink":"https://ultronxr.xyz/2019/01/19/The-Comparison-of-parseInt-and-valueOf-in-java/","excerpt":"Java编程中字符串转数字是经常遇到的事，在Integer类下面有parseInt和valueOf两个方法，以前纠结过用哪个方法，现在就比较一下两个方法的区别。","text":"Java编程中字符串转数字是经常遇到的事，在Integer类下面有parseInt和valueOf两个方法，以前纠结过用哪个方法，现在就比较一下两个方法的区别。 一、parseInt源码直接上Java源代码是最直观能看出区别的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//Java 1.8 库中 parseInt 的两种方法源码/** * Parses the string argument as a signed integer in the radix * specified by the second argument. The characters in the string * must all be digits of the specified radix (as determined by * whether &#123;@link java.lang.Character#digit(char, int)&#125; returns a * nonnegative value), except that the first character may be an * ASCII minus sign &#123;@code '-'&#125; (&#123;@code '\\u005Cu002D'&#125;) to * indicate a negative value or an ASCII plus sign &#123;@code '+'&#125; * (&#123;@code '\\u005Cu002B'&#125;) to indicate a positive value. The * resulting integer value is returned. * An exception of type &#123;@code NumberFormatException&#125; is * thrown if any of the following situations occurs: * * One. The first argument is &#123;@code null&#125; or is a string of * length zero. * Two. The radix is either smaller than * &#123;@link java.lang.Character#MIN_RADIX&#125; or * larger than &#123;@link java.lang.Character#MAX_RADIX&#125;. * Three. Any character of the string is not a digit of the specified * radix, except that the first character may be a minus sign * &#123;@code '-'&#125; (&#123;@code '\\u005Cu002D'&#125;) or plus sign * &#123;@code '+'&#125; (&#123;@code '\\u005Cu002B'&#125;) provided that the * string is longer than length 1. * Four. The value represented by the string is not a value of type * &#123;@code int&#125;. * * @param s the &#123;@code String&#125; containing the integer * representation to be parsed * @param radix the radix to be used while parsing &#123;@code s&#125;. * @return the integer represented by the string argument in the * specified radix. * @exception NumberFormatException if the &#123;@code String&#125; * does not contain a parsable &#123;@code int&#125;. */public static int parseInt(String s, int radix) throws NumberFormatException &#123; //略&#125;/** * Parses the string argument as a signed decimal integer. The * characters in the string must all be decimal digits, except * that the first character may be an ASCII minus sign &#123;@code '-'&#125; * (&#123;@code '\\u005Cu002D'&#125;) to indicate a negative value or an * ASCII plus sign &#123;@code '+'&#125; (&#123;@code '\\u005Cu002B'&#125;) to * indicate a positive value. The resulting integer value is * returned, exactly as if the argument and the radix 10 were * given as arguments to the &#123;@link #parseInt(java.lang.String, * int)&#125; method. * * @param s a &#123;@code String&#125; containing the &#123;@code int&#125; * representation to be parsed * @return the integer value represented by the argument in decimal. * @exception NumberFormatException if the string does not contain a * parsable integer. */public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125; 那一大段官方注释八成懒得看吧，我就简洁一点说。parseInt有两种方法，一种是带基数radix参数的，一种是不带的。 首先要注意的是parseInt方法返回的最终结果是一个int基本类型。 带有radix参数的方法的含义是，把字符串s按照radix进制进行处理（但是radix的含义不是完全是进制，注意！）。字符串中的字符除了第一位可以是正号+或负号-，其他位必须是数字0-9或小写a-z、大写A-Z字母，而且整个字符串代表的数字必须是整数，否则就会抛出NumberFormatException。此外，radix的取值返回需要落在[2, 36]，即 java.lang.Character.[MIN_RADIX, MAX_RADIX]的区间内。大于等于2因为小于2进制无意义，小于等于36因为z（或Z）字母所能代表的最大进制是35进制（0-9十个，英文字母26个）。 不带redix参数的方法实际上就是调用上面带radix参数的方法，把radix参数置为10。字符串的要求是除了第一位可以是正号+或负号-，其他位必须都是数字0-9。 网上说的一些特殊情况，包括字符串以0x开头就会默认解析成十六进制，字符串开头为0就会解析成八或十六进制数，这些我简单验证之后发现结果并非如此或者直接抛出异常，鉴于可能是运行环境或者java版本不同，所以这里暂不深究。 二、valueOf源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//Java 1.8 库中 valueOf 的两种方法源码/** * Returns an &#123;@code Integer&#125; object holding the value * extracted from the specified &#123;@code String&#125; when parsed * with the radix given by the second argument. The first argument * is interpreted as representing a signed integer in the radix * specified by the second argument, exactly as if the arguments * were given to the &#123;@link #parseInt(java.lang.String, int)&#125; * method. The result is an &#123;@code Integer&#125; object that * represents the integer value specified by the string. * * In other words, this method returns an &#123;@code Integer&#125; * object equal to the value of: * &#123;@code new Integer(Integer.parseInt(s, radix))&#125; * * @param s the string to be parsed. * @param radix the radix to be used in interpreting &#123;@code s&#125; * @return an &#123;@code Integer&#125; object holding the value * represented by the string argument in the specified * radix. * @exception NumberFormatException if the &#123;@code String&#125; * does not contain a parsable &#123;@code int&#125;. */ public static Integer valueOf(String s, int radix) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s,radix)); &#125; /** * Returns an &#123;@code Integer&#125; object holding the * value of the specified &#123;@code String&#125;. The argument is * interpreted as representing a signed decimal integer, exactly * as if the argument were given to the &#123;@link * #parseInt(java.lang.String)&#125; method. The result is an * &#123;@code Integer&#125; object that represents the integer value * specified by the string. * * In other words, this method returns an &#123;@code Integer&#125; * object equal to the value of: * &#123;@code new Integer(Integer.parseInt(s))&#125; * * @param s the string to be parsed. * @return an &#123;@code Integer&#125; object holding the value * represented by the string argument. * @exception NumberFormatException if the string cannot be parsed * as an integer. */ public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10)); &#125; /** * Returns an &#123;@code Integer&#125; instance representing the specified * &#123;@code int&#125; value. If a new &#123;@code Integer&#125; instance is not * required, this method should generally be used in preference to * the constructor &#123;@link #Integer(int)&#125;, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param i an &#123;@code int&#125; value. * @return an &#123;@code Integer&#125; instance representing &#123;@code i&#125;. * @since 1.5 */ public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 需要注意valueOf方法返回的最终结果是一个Integer类。 从源码可以看出，前两个valueOf方法同样有含radix参数和不含radix参数两种，但实际上都是调用了parseInt方法。先调用parseInt把字符串转成数字，然后调用第三个参数为int的valueOf(int)方法，最终返回一个Integer类。 在第三个valueOf(int)方法中我们可以看到，如果转出来的数字是在[-128, 127]区间内的话，会返回一个存在IntegerCache缓存中的Integer类，否则就new一个新的类再返回。这样的意义是预先产生一些常用数字的类放在缓存中，这样就有很大几率节省新建类的时间了。 三、选用哪种方法这个很难说，每个人都有不同的习惯，平时使用基本上不用刻意纠结，两者效率差不太多。 如果只是获取字符串代表的数值的话，优先推荐parseInt方法，因为它少了“装箱”的操作，单纯返回一个基本类型，所以稍稍更加高效。","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"}]},{"title":"使用 Navicat 的SSH连接远程服务器上的MySQL","slug":"Connect-to-mysql-on-server-using-navicat","date":"2019-01-04T15:20:26.000Z","updated":"2019-01-04T16:19:01.795Z","comments":true,"path":"2019/01/04/Connect-to-mysql-on-server-using-navicat/","link":"","permalink":"https://ultronxr.xyz/2019/01/04/Connect-to-mysql-on-server-using-navicat/","excerpt":"开发中会经常使用到服务器上的mysql，直接使用命令行对操作数据库多有不便。所以可以使用Navicat软件直接连接远程数据库进行操作。这里就简单说一下如何设置Navicat使用SSH远程连接数据库。","text":"开发中会经常使用到服务器上的mysql，直接使用命令行对操作数据库多有不便。所以可以使用Navicat软件直接连接远程数据库进行操作。这里就简单说一下如何设置Navicat使用SSH远程连接数据库。 一、设置服务器端mysql可以使用远程连接功能这个在前面的文章里说过了，点击这个链接跳转到设置Ubuntu服务器上的MySQL可以使用远程连接 二、设置Navicat的SSH连接和MySQL连接1.设置原理这里使用SSH连接远程的MySQL。 原理是 SSH选项卡中的设置是使用SSH通道连接并登录你的服务器，常规选项卡中设置的是连接你的mysql；先使用SSH连接并登录你的服务器，再用localhost连接你的mysql。 所以你应该在SSH选项卡的主机选项中填写远程服务器的公网ip，账户密码是你登录系统的账户名和密码；而在常规选项卡中的主机选项应该是localhost，账户密码则应该是mysql的账户名和密码。 有些博客上在常规选项卡中的主机写的不是localhost，是因为他没有通过SSH ！ 2.设置过程打开Navicat，点击左上角的 连接–&gt;MySQL 来新建一个连接； 在弹出的对话框中切换到SSH选项卡，勾上使用SSH通道复选框，在下面的主机输入框填写远程服务器的公网ip，账户名密码输入框填写登录服务器的账户名和密码，端口为默认的SSH端口22不变（如果修改过服务器ssh端口则需要另行修改）； 切换到常规选项卡，连接名随意填写，下面的主机输入框填写localhost，账户名密码输入框填写登录mysql的账户名和密码，端口为默认的mysql端口3306不变（如果修改过数据库端口则需另行修改）； 设置完后点击左下角的测试连接按钮，如果弹出连接成功说明设置完成。","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://ultronxr.xyz/tags/mysql/"},{"name":"navicat","slug":"navicat","permalink":"https://ultronxr.xyz/tags/navicat/"}]},{"title":"设置Ubuntu服务器上的MySQL可以使用远程连接","slug":"Let-mysql-on-Ubuntu-use-remote-connections","date":"2019-01-02T08:13:43.000Z","updated":"2019-01-02T08:57:55.541Z","comments":true,"path":"2019/01/02/Let-mysql-on-Ubuntu-use-remote-connections/","link":"","permalink":"https://ultronxr.xyz/2019/01/02/Let-mysql-on-Ubuntu-use-remote-connections/","excerpt":"设置Ubuntu服务器上的MySQL可以使用远程连接，用于给Navicat连接或者用代码进行数据库远程操作。","text":"设置Ubuntu服务器上的MySQL可以使用远程连接，用于给Navicat连接或者用代码进行数据库远程操作。 一、开放服务器mysql端口默认mysql端口为3306，到服务器控制台的安全组策略中添加一条策略，包含以下内容： 1234567规则方向：入方向授权策略：允许协议类型：MYSQL(3306) 或 自定TCP端口范围：3306/3306优先级：1授权类型：IPv4地址段访问授权对象：你的ip地址/端口 或 0.0.0.0/0 保存即可。 二、修改mysql配置文件使用netstat -an | grep 3306命令查看系统监听的对应于3306端口的ip，发现是127.0.0.1:3306，说明只监听了本地的3306端口。 mysql默认配置文件为/etc/mysql/mysql.conf.d/mysqld.cnf文件（有些博客写的不是这个文件），找到下面这一行，在行首添加#号把这行注释掉： 1bind-address = 127.0.0.1 保存退出。 重启mysql服务（具体命令看步骤三的内容），再使用netstat -an | grep 3306命令查看，监听的ip变成:::3306即可。 三、重启mysql服务以下为所有mysql启动、停止、重启命令： 1234567891011121314启动mysql：sudo /etc/init.d/mysql start 或sudo service mysql start停止mysql：sudo /etc/init.d/mysql stop 或sudo service mysql stop重启mysql：sudo/etc/init.d/mysql restart 或sudo service mysql restart 四、修改mysql权限使用 mysql -u root -p命令输入密码登录mysql，依次运行以下命令： 123use mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;FLUSH PRIVILEGES; 大功告成！","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://ultronxr.xyz/tags/mysql/"}]},{"title":"Ubuntu 16.04 LTS 的apt换源","slug":"Change-default-apt-source-to-ali-source-in-ubuntu16-04LTS","date":"2018-12-25T02:46:41.000Z","updated":"2018-12-25T05:34:44.553Z","comments":true,"path":"2018/12/25/Change-default-apt-source-to-ali-source-in-ubuntu16-04LTS/","link":"","permalink":"https://ultronxr.xyz/2018/12/25/Change-default-apt-source-to-ali-source-in-ubuntu16-04LTS/","excerpt":"为了apt安装和更新加快速度，这里选择把默认源更换成阿里源。","text":"为了apt安装和更新加快速度，这里选择把默认源更换成阿里源。 一、备份系统默认源sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak 二、查看系统版本详细信息lsb_release -c 查看列出的系统信息的Codename一项后面的值，注意这里不同版本的Ubuntu的值是不同的，不要搞错！！！ 记住上面的值，例如Ubuntu 16.04 LTS的Codename一般是xenial，其他的一般如下： 123456789Ubuntu 12.04 (LTS)代号为preciseUbuntu 14.04 (LTS)代号为trustyUbuntu 15.04 代号为vividUbuntu 15.10 代号为wilyUbuntu 16.04 (LTS)代号为xenial 三、新建 /etc/apt/sources.list 并修改内容sudo vim /etc/apt/sources.list 如果第二步的Codename的值是xenial的话，直接加入以下内容即可： 1234567891011121314151617deb-src http://archive.ubuntu.com/ubuntu xenial main restricteddeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 其他的版本的话，需要把上面内容中的xenial改成其他版本的Codename再添加。 四、更新apt使其生效sudo apt-get update 五、备注这里顺便备注一下，apt-get update和apt-get upgrade的区别： 前者是更新系统软件列表，后者是更新软件； 所以更新软件时应该先update一下再upgrade。","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"apt","slug":"apt","permalink":"https://ultronxr.xyz/tags/apt/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"}]},{"title":"Ubuntu 16.04 LTS 简易安装mysql","slug":"Installation-of-mysql-in-ubuntu16-04LTS","date":"2018-12-25T02:43:18.000Z","updated":"2018-12-25T03:33:07.811Z","comments":true,"path":"2018/12/25/Installation-of-mysql-in-ubuntu16-04LTS/","link":"","permalink":"https://ultronxr.xyz/2018/12/25/Installation-of-mysql-in-ubuntu16-04LTS/","excerpt":"完全使用命令行安装mysql。","text":"完全使用命令行安装mysql。 一、安装依次执行以下命令： sudo apt-get install mysql-server sudo apt-get install mysql-client sudo apt-get install libmysqlclient-dev 安装过程中会有一个粉红色界面让你输入数据库root用户的密码，输好之后不要忘了。 二、登录数据库验证输入以下命令，以root用户身份输入密码的形式登录数据库： mysql -u root -p 输入密码回车，如果提示欢迎登录数据库，然后命令行的标志变成了mysql&gt;，说明安装成功。 可以输入show databases;查看所有存在的数据库。 注意mysql命令最后要带分号才是完整的。","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"mysql","slug":"mysql","permalink":"https://ultronxr.xyz/tags/mysql/"}]},{"title":"Ubuntu 16.04 LTS 下安装Tomcat 8","slug":"Installation-of-tomcat8-in-ubuntu16-04LTS","date":"2018-12-25T02:43:09.000Z","updated":"2018-12-25T06:17:53.965Z","comments":true,"path":"2018/12/25/Installation-of-tomcat8-in-ubuntu16-04LTS/","link":"","permalink":"https://ultronxr.xyz/2018/12/25/Installation-of-tomcat8-in-ubuntu16-04LTS/","excerpt":"Ubuntu 16.04 LTS 下安装Tomcat 8 。","text":"Ubuntu 16.04 LTS 下安装Tomcat 8 。 一、下载Tomcat8压缩包如果知道确切的下载链接的话，可以直接使用wget命令直接下载到Ubuntu，否则可以先下载到Windows再上传到Ubuntu。 这里使用后者方法，请另行下载Tomcat8的压缩包： apache-tomcat-8.5.23.tar.gz 用ftp工具把压缩包上传到Ubuntu，这里以上传到~/temp/目录为例。 二、解压到指定目录进入/usr/local/目录，创建tomcat文件夹： cd /usr/local mkdir tomcat 把压缩包移动到/usr/local/tomcat/目录并解压： mv ~/temp/apache-tomcat-8.5.23.tar.gz /usr/local/tomcat/ tar -zxvf apache-tomcat-8.5.23.tar.gz 解压出来的应该是一个名为apache-tomcat-8.5.23的文件夹。 三、配置Tomcat修改环境变量： sudo vim /etc/profile 添加以下内容（md代码块前带有行号，请不要连行号一起复制！）： 12#tomcatexport TOMCAT_HOME=/usr/local/tomcat/apache-tomcat-8.5.23 保存退出，运行以下命令使环境变量生效： source /etc/profile 四、启动和停止Tomcat进入Tomcat安装目录： cd /usr/local/tomcat/apache-tomcat-8.5.23/bin/ 运行启动脚本： ./startup.sh 如果最后显示 Tomcat started. 的内容，说明Tomcat启动成功。 另外，停止运行的脚本也在相同目录下，运行即可： ./shutdown.sh 注意：如果在运行脚本时提示权限问题，无法运行，请使用chmod添加运行权限。 五、验证Tomcat是否启动成功如果只在Ubuntu中验证，可以使用如下命令： curl 127.0.0.1:8080 如果显示了Tomcat欢迎页面的HTML代码，则说明运行成功： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Apache Tomcat/8.5.23&lt;/title&gt; &lt;link href=\"favicon.ico\" rel=\"icon\" type=\"image/x-icon\" /&gt; &lt;link href=\"favicon.ico\" rel=\"shortcut icon\" type=\"image/x-icon\" /&gt; &lt;link href=\"tomcat.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"wrapper\"&gt; &lt;div id=\"navigation\" class=\"curved container\"&gt; &lt;span id=\"nav-home\"&gt;&lt;a href=\"http://tomcat.apache.org/\"&gt;Home&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-hosts\"&gt;&lt;a href=\"/docs/\"&gt;Documentation&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-config\"&gt;&lt;a href=\"/docs/config/\"&gt;Configuration&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-examples\"&gt;&lt;a href=\"/examples/\"&gt;Examples&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-wiki\"&gt;&lt;a href=\"http://wiki.apache.org/tomcat/FrontPage\"&gt;Wiki&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-lists\"&gt;&lt;a href=\"http://tomcat.apache.org/lists.html\"&gt;Mailing Lists&lt;/a&gt;&lt;/span&gt; &lt;span id=\"nav-help\"&gt;&lt;a href=\"http://tomcat.apache.org/findhelp.html\"&gt;Find Help&lt;/a&gt;&lt;/span&gt; &lt;br class=\"separator\" /&gt; &lt;/div&gt; &lt;div id=\"asf-box\"&gt; &lt;h1&gt;Apache Tomcat/8.5.23&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"upper\" class=\"curved container\"&gt; &lt;div id=\"congrats\" class=\"curved container\"&gt; &lt;h2&gt;If you're seeing this, you've successfully installed Tomcat. Congratulations!&lt;/h2&gt; &lt;/div&gt; &lt;div id=\"notice\"&gt; &lt;img src=\"tomcat.png\" alt=\"[tomcat logo]\" /&gt; &lt;div id=\"tasks\"&gt; &lt;h3&gt;Recommended Reading:&lt;/h3&gt; &lt;h4&gt;&lt;a href=\"/docs/security-howto.html\"&gt;Security Considerations HOW-TO&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"/docs/manager-howto.html\"&gt;Manager Application HOW-TO&lt;/a&gt;&lt;/h4&gt; &lt;h4&gt;&lt;a href=\"/docs/cluster-howto.html\"&gt;Clustering/Session Replication HOW-TO&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 下面还有很多，这里省略 --&gt; &lt;!-- 下面还有很多，这里省略 --&gt; 或者也可以直接访问Ubuntu的公网ip的8080端口，会显示Tomcat欢迎页面（针对Ubuntu服务器）。 六、修改端口默认的Tomcat端口为8080端口，一般在安装后都会修改成80端口，以下是修改方法（修改前先停止Tomcat运行！！！）： 修改Tomcat配置文件： vim /usr/local/tomcat/apache-tomcat-8.5.23/conf/server.xml 找到如下内容： 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 把其中的port=”8080”修改成port=”80”，保存退出，重启Tomcat即可生效。 但是还有一种特殊情况，即单单修改这里是无效的，这里暂时先不讨论。 七、设置Tomcat ManagerTomcat首页默认是有自带的Manager管理程序，即三个按钮Server Status、Manager App、Host Manager是可以进行管理员登录然后查看Tomcat运行状况的。 如果不手动配置，点击进去是404页面。下面是配置方法（同样配置前先停止Tomcat！！！）： 修改tomcat-users.xml配置文件： vim /usr/local/tomcat/apache-tomcat-8.5.23/conf/tomcat-users.xml 在&lt;tomcat-users&gt;和&lt;tomcat-users/&gt;标签之间添加以下内容： 12&lt;role rolename=\"manager-gui\"/&gt;&lt;user username=\"replace me\" password=\"replace me\" roles=\"manager-gui\"/&gt; 把其中的两个replace me分别修改成用户名和密码，保存退出即可。 重启服务器，点击首页的管理按钮，输入账户名和密码即可查看Tomcat运行状态。 注意：服务器上配置了Tomcat Manager默认只能从本地访问，如果需要远程访问，请修改以下配置文件： vim /usr/local/tomcat/apache-tomcat-8.5.23/webapps/manager/META-INF/context.xml 找到如下内容： 12&lt;Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" /&gt; 其中的allow的值就是允许访问Tomcat Manager的ip地址，可以看到默认只允许本地ip访问，可以在allow的值的末尾添加一个竖线然后写上自己的ip。 如添加之后为： 12&lt;Valve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1|152.163.163.163\" /&gt; 保存退出，重启Tomcat即可生效。 八、备注tomcat安装目录/usr/local/tomcat/apache-tomcat-8.5.23 webapp包目录/usr/local/tomcat/apache-tomcat-8.5.23/webapps 启动tomcat命令/usr/local/tomcat/apache-tomcat-8.5.23/bin/startup.sh 停止tomcat命令/usr/local/tomcat/apache-tomcat-8.5.23/bin/shutdown.sh","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"tomcat","slug":"tomcat","permalink":"https://ultronxr.xyz/tags/tomcat/"}]},{"title":"Ubuntu 16.04 LTS 下安装JDK1.8和JRE","slug":"Setting-up-of-jdk1-8-in-ubuntu16-04LTS","date":"2018-12-25T02:42:42.000Z","updated":"2018-12-25T05:39:52.437Z","comments":true,"path":"2018/12/25/Setting-up-of-jdk1-8-in-ubuntu16-04LTS/","link":"","permalink":"https://ultronxr.xyz/2018/12/25/Setting-up-of-jdk1-8-in-ubuntu16-04LTS/","excerpt":"Ubuntu 16.04 LTS 下安装JDK1.8和JRE。","text":"Ubuntu 16.04 LTS 下安装JDK1.8和JRE。 一、下载JDK1.8的压缩包（64位）如果知道确切的下载链接的话，可以直接使用wget命令直接下载到Ubuntu，否则可以先下载到Windows再上传到Ubuntu。 这里使用后者方法，请另行下载JDK1.8的压缩包： jdk-8u181-linux-x64.tar.gz （里面自带JRE） 用ftp工具把压缩包上传到Ubuntu，这里以上传到~/temp/目录为例。 二、解压到指定目录进入/usr/lib/目录，创建java文件夹： cd /usr/lib mkdir java 把压缩包移动到/usr/lib/java/目录并解压： mv ~/temp/jdk-8u181-linux-x64.tar.gz /usr/lib/java/ tar -zxvf jdk-8u181-linux-x64.tar.gz 解压出来的应该是一个名为jdk1.8.0_181的文件夹。 三、配置环境变量修改环境变量文件： sudo vim /etc/profile 在末尾添加如下内容（md代码块前带有行号，请不要连行号一起复制！）： 12345#set java environmentexport JAVA_HOME=/usr/lib/java/jdk1.8.0_181export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:%&#123;JAVA_HOME&#125;/lib:%&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 保存退出，使用以下命令使环境变量生效： source /etc/profile 四、验证是否安装成功输入java -version命令，如果显示以下内容则配置完成： 123java version &quot;1.8.0_181&quot;Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 五、提醒请注意下载的JDK是32位（x86）的还是64位（x64）的，不符合要求的JDK即使配置完成也无法使用！！","categories":[{"name":"Ubuntu16.04LTS安装/配置全家桶","slug":"Ubuntu16-04LTS安装-配置全家桶","permalink":"https://ultronxr.xyz/categories/Ubuntu16-04LTS安装-配置全家桶/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://ultronxr.xyz/tags/ubuntu/"},{"name":"jdk","slug":"jdk","permalink":"https://ultronxr.xyz/tags/jdk/"},{"name":"jre","slug":"jre","permalink":"https://ultronxr.xyz/tags/jre/"}]},{"title":"word和pdf的比较——为什么正式场合更多使用pdf","slug":"Comparison-of-pdf-and-word","date":"2018-12-24T16:03:46.000Z","updated":"2019-01-02T09:04:07.485Z","comments":true,"path":"2018/12/25/Comparison-of-pdf-and-word/","link":"","permalink":"https://ultronxr.xyz/2018/12/25/Comparison-of-pdf-and-word/","excerpt":"学习工作中，word的格式排版确实让人伤脑筋。而说到word，则不得不提在正式场合更多使用的pdf格式。正巧前几天看到了一遍关于这个的博客写得很好，我这里简单总结一下，比较一下两者的特点和不同，两者的格式转换为什么这么困难，以及为什么正式场合更多使用pdf而不是word。","text":"学习工作中，word的格式排版确实让人伤脑筋。而说到word，则不得不提在正式场合更多使用的pdf格式。正巧前几天看到了一遍关于这个的博客写得很好，我这里简单总结一下，比较一下两者的特点和不同，两者的格式转换为什么这么困难，以及为什么正式场合更多使用pdf而不是word。 一、word和pdf的特点pdf格式有“通用性好”、“格式不易变化”等特点。其中“通用性好”指的是不论是在什么平台或者用什么版本的pdf阅读器打开pdf文件，pdf总是能够展现出相对正确的格式。“格式不易变化”则是指一个pdf文件一旦生成，他就会一直保持相对稳定的格式，不会变化。而反观word，仅仅是换了台计算机打开，其中的文本格式和字体等可能就会发生变化，让人难以阅读，更别说不同的人用着不同版本的word了。 但是pdf也有一些让人“敬而远之”的缺点。第一就是“无法复制”，大部分的pdf文件都无法通过简单的“选择——复制”操作来复制其中的“文本”，这恐怕是学生党最不喜欢pdf的地方了o(╥﹏╥)o，连简单的复制都没法实现，怎么不学学word？？？第二则是“难以编辑”，就连复制都难，更别提修改其中的内容了。在这点上，word就显得使用更加简单了。 word和pdf为什么会有如此大的不同？下面我会简单谈谈word和pdf的原理，从而解答这些问题。 二、word和pdf的实现原理1.word的实现原理首先，word的实现原理是标记语言 (Markup Language) 文档，啥意思？就是说word中的文本显示效果是通过在文本周围加上属性标签来实现控制显示样式等操作的，下面是一个简单的例子： 新建一张空白word，在中间打上“Hello world!”一行文字，设置水平居中，对doc文件进行解包处理，得到的相关结果如下： 1234&lt;w:pPr&gt;&lt;w:jcw:val=&quot;center&quot;/&gt;&lt;w:rPr&gt;&lt;w:rFontsw:ascii=&quot;Times&quot;w:hAnsi=&quot;Times&quot;/&gt;&lt;w:langw:val=&quot;en-US&quot;/&gt;&lt;/w:rPr&gt;&lt;/w:pPr&gt;&lt;w:rw:rsidRPr=&quot;003C75CF&quot;&gt;&lt;w:rPr&gt;&lt;w:rFontsw:ascii=&quot;Times&quot;w:hAnsi=&quot;Times&quot;/&gt;&lt;/w:rPr&gt;&lt;w:t&gt;Hello world!&lt;/w:t&gt;&lt;/w:r&gt; 现在可以很清楚得看到，代码中全是属性标签。从包含了输入内容的最后一行代码看起，字体在w:rFontsw标签中定义为Times，第一行的w:jcw标签控制的是段落样式center居中对齐。 这就是标记语言，实际上和HTML等文件的工作原理类似。 2.*pdf的实现原理pdf的本质就是数字化的纸张，计算机对pdf的操作实际上是打印 首先pdf，可以理解为“电子版的虚拟打印”，就是实体文档在计算机中的影像，而不是实际的文本。计算机对pdf的操作可以理解为“模拟对一张实际的纸张的操作”，例如进行pdf的复制操作，可以理解为“把一张纸上的内容抄写到另一张纸上”，计算机并不知道它抄写的是什么，只是“依样画葫芦”地抄写，而不是复制。 知道了这个，就不难理解为什么pdf有难以编辑的缺点了，一份pdf打印出来之后，它的内容，包括文字的内容，文字相对于纸张的位置，文字的字体、大小等都被确定了，很难被改变。 其他格式的文件格式都是“新建”或者“保存”的，而pdf则是“导出”或者是“打印”的，这也说明了pdf的“数字化纸张”的特点。 下面同样以一份pdf文件，其中居中打印了“Hello world!”文本的源码来作说明： 123BT10011036572 Tm /TT1 12 Tf [ (He) 24 (l) -48 (l) -48 (o) ]TJETBT 10011147572 Tm /TT1 12 Tf ( ) TjETBT 10011160572 Tm /TT1 12 Tf [ (w) 24 (or) -84 (l) -24 (d) ] TJET 这些符号也许会让你一头雾水，但是查阅相关资料，进行可读化“翻译”之后，则是以下内容： 123【文字开始】 缩放比例1倍 坐标(1036,572) 【文字定位】 /TT1 12磅 【选择字体】 [ (He) 间距24 (l) 间距-48 (l) 间距-48 (o) ] 【绘制文字】【文字结束】【文字开始】 缩放比例1倍 坐标(1147,572) 【文字定位】 /TT1 12磅 【选择字体】 (空格) 【绘制文字】【文字结束】【文字开始】 缩放比例1倍 坐标(1060,572) 【文字定位】 /TT1 12磅 【选择字体】 [ (w) 间距24 (or) 间距-84 (l) 间距-24 (d) ] 【绘制文字】【文字结束】 我们不难想象这是一种刻板的机械动作，计算机控制了一支笔，不断修改笔触的位置和大小，在数字纸张上画下内容。因此，用“打印”来形容计算机处理pdf文件内容的过程最合适不过。 三、为什么word的格式容易走样？了解了实现原理，解释起来就简单多了，word的标记语言尽管十分方便，可以随意修改，复制，变换；但是这也留了很大的漏洞，比如Times字体究竟长什么样，我这里找不到Times模版怎么办？又比如居中是怎样居中，居中的参考系是什么？这些问题都留给word文档处理软件来处理，这就需要不同的word文档处理软件统一标准，但是这又谈何容易，微软一家的word软件在不同版本情况下处理同一个问题的解决方法都是不同的。。。-_-|| 四、为什么正式场合更多使用pdf？答：pdf样式不容易变化，而且方便直接进行实体打印。 所以下次交简历的时候尽量不要发一份word给HR了，鬼知道HR用的是哪一年版本的word！！！（开玩笑的啦-.-） 五、链接资源我的这篇博客主要对下面这篇博客总结，有些更加详细的问题和解释内容并没有提及，所以有兴趣的话可以进入下面这篇博客深入学习。在此表示感谢。（侵删！！！） 为什么 PDF 是最好的「文件格式」｜ 科普","categories":[{"name":"技术杂谈","slug":"技术杂谈","permalink":"https://ultronxr.xyz/categories/技术杂谈/"}],"tags":[{"name":"word","slug":"word","permalink":"https://ultronxr.xyz/tags/word/"},{"name":"pdf","slug":"pdf","permalink":"https://ultronxr.xyz/tags/pdf/"}]},{"title":"Hexo博客测试","slug":"Hexo-Test","date":"2018-12-20T02:48:17.000Z","updated":"2018-12-25T02:52:29.220Z","comments":true,"path":"2018/12/20/Hexo-Test/","link":"","permalink":"https://ultronxr.xyz/2018/12/20/Hexo-Test/","excerpt":"—这里是文章摘要—这是该博客对于Hexo的测试页面。","text":"—这里是文章摘要—这是该博客对于Hexo的测试页面。 标题1标题2正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文正文 12//C测试printf(\"HelloWorld\"); 12//C++测试cout &lt;&lt; \"HelloWorld\" &lt;&lt; endl; 12//java测试System.out.println(\"HelloWorld\"); 123# python测试import math;print(\"HelloWorld\");","categories":[{"name":"测试","slug":"测试","permalink":"https://ultronxr.xyz/categories/测试/"}],"tags":[{"name":"test","slug":"test","permalink":"https://ultronxr.xyz/tags/test/"}]},{"title":"Java中的try catch finally语法（坑）","slug":"Try-catch-finally-statement-in-java","date":"2018-11-11T16:00:00.000Z","updated":"2018-12-22T10:49:34.095Z","comments":true,"path":"2018/11/12/Try-catch-finally-statement-in-java/","link":"","permalink":"https://ultronxr.xyz/2018/11/12/Try-catch-finally-statement-in-java/","excerpt":"以前都没有仔细注意过try catch finally的用途，只知道在代码里try catch一下，然后println一下异常提示。今天在做项目的时候被这个坑了好久，感叹自己学艺不精！下面讲一下里面的心路历程。","text":"以前都没有仔细注意过try catch finally的用途，只知道在代码里try catch一下，然后println一下异常提示。今天在做项目的时候被这个坑了好久，感叹自己学艺不精！下面讲一下里面的心路历程。 一、写这篇文章的起因 超级超级低级的错误！！！ 以前都没有仔细注意过try catch finally的用途，只知道在代码里try catch一下，然后println一下异常提示。 今天在做项目的时候被这个坑了好久，感叹自己学艺不精！下面讲一下里面的心路历程。 直接上代码（第一版的代码）： 123456789101112131415161718192021222324252627/** * @Description: 这是一个线程中的execute方法实例，用来在rabbitmq里注册一个consumer消费者，每隔一定时间去取消息队列中的信息 */public class TransferExecutor implements Runnable&#123; public void execute()&#123; try&#123; ...... Consumer consumer = new DefaultConsumer(channel); while(true)&#123; channel.basicConsume(queueName, autoAck, consumer); Thread.sleep(100); &#125; &#125; catch (Exception ex)&#123; ex.printStackTrace(); &#125; finally &#123; MyRabbitMQ.closeChannelAndConnection(channel, connection); &#125; &#125; @Override public void run()&#123; execute(); &#125;&#125; 上面这段代码完全可以正常运行，甚至一段相当长的时间内都看不出异常。。。 直到我用rabbitmq自带的可视化界面看了一下我的队列，发现我的队列绑定着上百个consumer（要不是IDEA报错我可能现在还没发现）。 原因是 channel.basicConsume() 方法并不是单单从队列中取出信息消费一次（重点），而是注册一个消费者consumer持续地进行消费，直至channel关闭或手动删除consumer。 修改了，然后就有了第二版代码： 123456789101112131415161718192021public class TransferExecutor implements Runnable&#123; public void execute()&#123; try&#123; ...... Consumer consumer = new DefaultConsumer(channel); channel.basicConsume(queueName, autoAck, consumer); //不是说注册消费者吗，那我就只注册一个呗。 &#125; catch (Exception ex)&#123; ex.printStackTrace(); &#125; finally &#123; MyRabbitMQ.closeChannelAndConnection(channel, connection); &#125; &#125; @Override public void run()&#123; execute(); &#125;&#125; 然后呢，代码直接就不能用了，不是说不能运行，而是publish新的消息没有消费者去处理，然后发现在队列上完全没有消费者绑着。 调了很久，一直找不出错误，一度怀疑是 Executors.newFixedThreadPool(10) 的线程池有问题。。。 然后这里把代码简化了就能一眼看出来了，try运行完了没有抛出异常直接就转到finally里的代码了，线程在运行，却关闭了消息队列的连接，当然没法消费了（再次重点）。 二、借此机会摘记一下try catch finally的用法和运行顺序 据说有些公司拿这个当过面试和笔试题（别人博客上看到的）。 考运行顺序一般是和return exit这些函数放在一起考的，详见下面的摘记或博客（这里我列了一些我看到的比较好的博客）： Java异常机制–try catch finally 执行顺序详解 Java异常捕获之try-catch-finally-return的执行顺序 以后会填坑的（小声逼逼..） 三、总结 学艺不精，继续努力！","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"},{"name":"problems","slug":"java/problems","permalink":"https://ultronxr.xyz/categories/java/problems/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"problems","slug":"problems","permalink":"https://ultronxr.xyz/tags/problems/"}]},{"title":"IDEA中编译器与项目的java版本不同导致编译失败的解决办法","slug":"Compiling-failure-due-to-the-differences-between-project-and-java-complier","date":"2018-09-30T16:00:00.000Z","updated":"2018-12-22T10:49:55.161Z","comments":true,"path":"2018/10/01/Compiling-failure-due-to-the-differences-between-project-and-java-complier/","link":"","permalink":"https://ultronxr.xyz/2018/10/01/Compiling-failure-due-to-the-differences-between-project-and-java-complier/","excerpt":"IDEA中编译器与项目的java版本不同导致编译失败的解决办法","text":"IDEA中编译器与项目的java版本不同导致编译失败的解决办法 一、错误征兆 IDEA中编译项目有时会出现以下几种报错情况，基本上是因为编译器和项目的java版本不匹配： 12@Override is not allowed when implementing interface method//Override不能用 12Error:java: Compilation failed: internal java compiler error //编译器出错 二、解决办法 1.先打开项目结构Project Structure对话框，选择Project选项卡，检查Project SDK和Project language level是否匹配，1.8的JDK应该对应于8的language level； 2.切换到Modules选项卡，检查language level是否匹配和上一步中的language level匹配； 3.打开IDEA系统设置对话框，定位到 Build,Execution,Deployment –&gt; Compiler –&gt; Java Compiler 选项卡，修改右侧的Module中的Target bytecode version，使其匹配当前的JDK版本； 4.因为我这里用的是1.8的JDK，所以其他的language level都是设置成8的，其他版本的JDK应该设置成相对应的数值。 三、参考资料 1.idea @Override is not allowed when implementing interface method解决办法 2.Error:java: Compilation failed: internal java compiler error 解决办法","categories":[{"name":"IDEA","slug":"IDEA","permalink":"https://ultronxr.xyz/categories/IDEA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://ultronxr.xyz/tags/IDEA/"}]},{"title":"在Windows上安装maven，并且在eclipse和IDEA中配置maven","slug":"How-to-install-maven-on-windows-and-the-setup-of-maven-in-eclipse-and-IDEA","date":"2018-09-30T16:00:00.000Z","updated":"2018-12-22T10:49:47.508Z","comments":true,"path":"2018/10/01/How-to-install-maven-on-windows-and-the-setup-of-maven-in-eclipse-and-IDEA/","link":"","permalink":"https://ultronxr.xyz/2018/10/01/How-to-install-maven-on-windows-and-the-setup-of-maven-in-eclipse-and-IDEA/","excerpt":"在Windows上安装maven，并且在eclipse和IDEA中配置maven","text":"在Windows上安装maven，并且在eclipse和IDEA中配置maven 一、下载和配置maven 1.下载maven压缩包进入Apache maven下载页面，选择Windows对应的maven压缩包，点击下载。如果有版本要求在下面的历史版本中找。 2.配置maven1) 配置前请先确认你正确安装了Java的jdk； 2) 把下载的压缩包解压到某路径内，我的是 D:\\JAVA\\apache-maven-3.5.4 ； 3) 修改maven配置： 打开 conf 文件夹内的 settings.xml 文件，按照下面修改： 在图示位置加上 下面这一段代码，作用是指定路径作为本地仓库所在的文件夹，你也可以指定其他的路径文件夹（默认的仓库是是C盘当前用户文件夹内的.m2文件夹，修改到别的位置防止C盘占用太多）： 1&lt;localRepository&gt;D:\\JAVA\\ApachemavenRepository&lt;/localRepository&gt; 继续在图片所示位置加上以下代码，注意要加在两个&lt;mirrors&gt;``标签之间，代码的作用是把阿里云maven仓库作为远程仓库： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 保存后关闭文件。 4) 接下来配置环境变量： 在 系统变量 中新建一个变量，名称为 MAVEN_HOME ，值为 D:\\JAVA\\apache-maven-3.5.4 （你解压maven的路径）； 在 系统变量 的 PATH 变量里新加一个值 %MAVEN_HOME%\\bin ； 保存退出。 5) 验证maven是否安装成功： 打开cmd窗口，输入 mvn -v 命令，如果输出了maven的版本信息，说明安装成功，如下图所示。 二、在eclipse中配置maven 1.点击菜单栏中的Windows选项，打开Preferences选项卡; 2.找到Maven选项里的Installations选项： 3.点击右侧的Add按钮，在弹出来的对话框中点击Diretory按钮，选择解压maven的目录； 4.选好后点击Finish按钮回到开始的选项处，发现列表中多了一条我们自定义的maven，把这条maven前面的复选框勾上，点击Apply按钮应用更改。 5.选择左边的User Settings选项； 6.点击第一个Browse按钮，选择解压maven路径下的conf文件夹里的settings.xml文件； 7.上一步完成后，你会发现第三个Local Repository处自动变成了你的maven配置文件里指定的本地仓库的路径； 8.点击Apply和Apply and Close应用后退出即可。 三、在IDEA中配置maven 1.点击菜单中的File选项，选择Settings； 2.定位到左边选项列表中的 Build,Execution,Deployment –&gt; Build Tools –&gt; Maven 选项； 3.点击Maven选项，在右边的 Maven home directory 处选择解压maven的路径， 在User settings file后面的Override勾勾打上，选择解压maven路径中conf文件夹内的settings.xml文件， 选择完成后，下面的Local repository会自动修改为配置文件中本地仓库的路径； 点击Apply保存修改； 4.点击Maven选项下的Importing选项，把 Importing Maven projects automatically 前面的勾勾上，点击Apply保存修改； 5.点击Maven选项下的Repositoroes选项，选中刚才我们自己设置的maven，点击右侧Update按钮更新本地仓库。 6.至此配置完成。 四、参考资料 1.apache maven下载页面 2.Eclipse配置maven环境 3.如何使用IntelliJ IDEA 配置Maven","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/categories/javaweb/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://ultronxr.xyz/tags/IDEA/"},{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/tags/javaweb/"},{"name":"maven","slug":"maven","permalink":"https://ultronxr.xyz/tags/maven/"},{"name":"eclipse","slug":"eclipse","permalink":"https://ultronxr.xyz/tags/eclipse/"}]},{"title":"使用IDEA创建maven web项目","slug":"Create-maven-web-project-using-IDEA","date":"2018-09-30T16:00:00.000Z","updated":"2018-12-22T10:49:51.604Z","comments":true,"path":"2018/10/01/Create-maven-web-project-using-IDEA/","link":"","permalink":"https://ultronxr.xyz/2018/10/01/Create-maven-web-project-using-IDEA/","excerpt":"使用IDEA创建maven web项目","text":"使用IDEA创建maven web项目 一、新建项目 1.在刚打开的IDEA页面点击 Create New Project 按钮 或者 在项目界面点击菜单中的 File–New–Project 选项； 2.在弹出的新建项目对话框中选择左边的Maven选项，在右侧列表中勾上Create from archetype复选框，选择maven-archetype-webapp选项，点击Next按钮进入下一步； 3.填写GroupId和ArtifactId，第一个是组织名称，第二个是项目标识名，两者意义的详细介绍自行百度，第三个Version 1.0-SNAPSHOT代表项目是测试版本，不是稳定版本，点击Next按钮进入下一步； 4.配置maven页面，可以使用IDEA自带的，也可以选择自己安装的maven。我这里是自己安装的maven，第一个Maven home directory选择maven的安装路径，第二个User settings file打上Override的勾，然后选择maven安装路径中conf文件夹下的settings.xml配置文件，其他的不用改，点击Next按钮进入下一步； 5.这里就改一下项目所在的路径就可以了，基本不变，点击Finish即可； 二、配置项目 1.新建的项目的文件树如下： 2.在main文件夹内新建两个并列的文件夹，一个是java，一个是resources。建好后点击菜单栏右上角的项目结构按钮，选择左边的Modules选项卡，在右边把java文件夹标记为Sources，把resources文件夹标记为Resources； 3.点击Apply后切换到Facets选项卡，点击右边的加号，选择Web，在弹出来的对话框中选择你的项目，点击OK； 4.点击OK后会自动跳转到Modules选项卡，切回到Facets选项卡，选中刚刚新建的Web，在右侧Deployment Description中，选中内容点击小铅笔图标，修改Path为当前项目的web.xml文件路径； 5.然后修改Web Resource Directories，选中内容点击小铅笔图标修改为当前项目的webapp目录，修改好后点击Apply； 6.切换到Artifacts选项卡，点击右边的加号，选择Web Application: Exploded，选择From Modules，在弹出来的对话框中选择当前项目，点击OK，完成后如下图； 7.点击Apply应用修改，点击OK关闭窗口，点击菜单栏右上方一个小锤子右边的Add Configuration按钮，在弹出来的对话框里点击加号，依次选择Tomcat Server – Local； 8.在右侧选择Deployment选项卡，点击右侧的加号，选择Artifact，完成后修改Application context为项目名（也可以是别的名称，这个是用来指定url中根目录下具体路径的）； 9.切换到Server选项卡，自上往下依次修改： Name 随便写 Application server 选一个tomcat，如何配置tomcat略 Open browser中的After launch前面的勾勾上就会在运行项目时自动打开浏览器，浏览器选择Chrome On ‘Update’ action 和 On frame deactivation两个选项都改成 Update classes and resources，这样修改代码就会自动更新到tomcat里而不用重启服务器 下面的HTTP端口按照自己的配置因人而异 10.点击Apply和OK后，点击右上方的运行按钮，就是一个向右的小三角，如果等待一会后浏览器打开跳转到了项目页面，显示了Hello World（index.jsp中的内容），说明配置成功。点击IDEA右上方红色的小方块停止运行。 三、导出项目成war包 1.打开Project Structure对话框，切换到Artifacts选项卡，点击加号新建，选择Application Web: Archive，如果配置了前面的Application Web: exploded的话，这里会有 ‘For 你的项目名称’ 的选项，直接点击这个，Output Directory可以修改成别的文件夹，点击Apply和OK退出； 2.点击菜单栏里的Build按钮，选择Build Artifacts选项，在弹出来的选项中选择后缀为 :war 的选项（没有exploded 的选项），点击Build就会生成war包了。 四、参考资料 1.idea2017创建maven web项目 2.IDEA中创建maven web项目的详细部署 3.idea将项目导出为war包","categories":[{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/categories/javaweb/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://ultronxr.xyz/tags/IDEA/"},{"name":"javaweb","slug":"javaweb","permalink":"https://ultronxr.xyz/tags/javaweb/"},{"name":"maven","slug":"maven","permalink":"https://ultronxr.xyz/tags/maven/"}]},{"title":"使用Photoshop创建4寸照","slug":"How-to-create-a-4-inch-photo-using-photoshop","date":"2018-09-21T16:00:00.000Z","updated":"2018-12-22T11:35:05.331Z","comments":true,"path":"2018/09/22/How-to-create-a-4-inch-photo-using-photoshop/","link":"","permalink":"https://ultronxr.xyz/2018/09/22/How-to-create-a-4-inch-photo-using-photoshop/","excerpt":"使用Photoshop创建4寸照","text":"使用Photoshop创建4寸照 一、处理方法 1.新建4寸（宽度：7.6cm 高度：10cm 分辨率：300dpi像素/英寸）大小的白色背景画布； 2.打开照片，拖进背景文件里，按住shift键等比例调整大小，完全盖住背景画布； 3.处理照片图层，锐化什么的。。。 4.右键照片图层，向下合并，与背景成为同一个图层； 5.保存即可。 二、参考资料 怎么用adobe photoshop做4寸照片","categories":[{"name":"photoshop","slug":"photoshop","permalink":"https://ultronxr.xyz/categories/photoshop/"}],"tags":[{"name":"photoshop","slug":"photoshop","permalink":"https://ultronxr.xyz/tags/photoshop/"}]},{"title":"Windows下 Java JDK 和 Tomcat 的安装配置","slug":"Java-jdk-setting-up-and-tomcat-installation","date":"2018-09-16T16:00:00.000Z","updated":"2018-12-22T11:33:34.896Z","comments":true,"path":"2018/09/17/Java-jdk-setting-up-and-tomcat-installation/","link":"","permalink":"https://ultronxr.xyz/2018/09/17/Java-jdk-setting-up-and-tomcat-installation/","excerpt":"Windows下 Java JDK 和 Tomcat 的安装配置","text":"Windows下 Java JDK 和 Tomcat 的安装配置 一、安装配置JDK1.安装配置JDKJDK压缩包下载解压到一个文件夹里，然后编辑系统环境变量 系统变量→新建 JAVA_HOME 变量，内容填写JDK解压后的根目录，如 D:\\JAVA\\jdk1.8.0_131 ； 系统变量→找到 Path 变量，添加 %JAVA_HOME%\\bin 和 %JAVA_HOME%\\jre\\bin 两个变量， 有些系统可能不支持 %JAVA_HOME% 这样的格式，就添加带绝对路径的 D:\\JAVA\\jdk1.8.0_131\\bin 和 D:\\JAVA\\jdk1.8.0_131\\jre\\bin 这样的变量； 系统变量→新建 CLASSPATH 变量，内容填写 .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 。 2.检验JDK是否安装成功打开 cmd 输入 java java -version javac 三个命令，如果都有输出提示如何使用命令或者显示java版本则安装成功，如果输出显示不是内部或外部命令，也不是可运行的程序或批处理文件什么的就是没有成功。 二、Windows下安装和配置Tomcat1.下载解压安装包进入Tomcat官网，在页面左边Download处选择合适的版本，点击进入下载页面，按照系统下载32位或者64位的压缩包； 把压缩包解压到合适的路径，我的路径是 C:\\Program Files\\Apache Software Foundation\\tomcat7.0.90 ，解压出来的文件截图： 2.配置安装Tomcat1) 在系统环境变量里的分别新建两个变量 CATALINA_BASE 和 CATALINA_HOME 里面填写的内容都是Tomcat的解压目录，我的是 C:\\Program Files\\Apache Software Foundation\\tomcat7.0.90 2) 在系统环境变量Path中添加两条内容： %CATALINA_HOME%\\lib %CATALINA_HOME%\\bin 3) 打开cmd进入 C:\\Program Files\\Apache Software Foundation\\tomcat7.0.90\\bin 目录， 执行 service.bat install 命令安装Tomcat服务（卸载Tomcat服务的命令： service.bat remove ）。 如果显示 The service ‘Tomcat x’ has been installed. 就是安装完成了。 4) 安装完成后打开系统服务管理，找到Tomcat服务，手动打开即可，也可以设置自动启动等选项。 3.添加Tomcat管理员用户1) 进入 C:\\Program Files\\Apache Software Foundation\\tomcat7.0.90\\conf 目录，打开 tomcat-users.xml 文件； 2) 在 &lt;tomcat-users&gt; 和 &lt;/tomcat-users&gt; 之间添加以下代码：1234&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;example1&quot; password=&quot;example1&quot; roles=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;admin-gui&quot;/&gt;&lt;user username=&quot;example2&quot; password=&quot;example2&quot; roles=&quot;admin-gui&quot;/&gt; 两个example1和example2是两组用户名和密码，按需要修改。 3) 修改完成后保存退出，重新启动Tomcat服务（重要！！！）。 4.验证Tomcat是否安装成功启动Tomcat服务后（如果不启动会显示网址无法访问），使用浏览器打开 http://localhost:8080/ 网址，如果显示下图则安装成功： 然后点击右边的三个按钮。 前两个按钮用example1的那组用户名密码登录，最后一个用example2的那组用户名密码登录，如果显示类似的界面则说明管理员账户可以正常使用。 如果显示这样的界面则说明管理员账户设置失败，按照页面提示重新设置即可（设置完了别忘了重启Tomcat服务！）。 最后标注一点，如果使用eclipse或者IDEA编译器运行JavaWeb项目，要先把Tomcat服务关闭，否则会报端口占用的错。除非自己修改Tomcat的端口。 三、参考资料 Tomcat官网 windows10配置jdk和Tomcat","categories":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://ultronxr.xyz/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://ultronxr.xyz/tags/jdk/"},{"name":"tomcat","slug":"tomcat","permalink":"https://ultronxr.xyz/tags/tomcat/"}]},{"title":"Windows下Redis的安装与设置","slug":"The-installation-and-setup-of-Redis-on-Windows","date":"2018-08-14T16:00:00.000Z","updated":"2018-12-22T10:50:05.755Z","comments":true,"path":"2018/08/15/The-installation-and-setup-of-Redis-on-Windows/","link":"","permalink":"https://ultronxr.xyz/2018/08/15/The-installation-and-setup-of-Redis-on-Windows/","excerpt":"Windows下Redis的安装与设置","text":"Windows下Redis的安装与设置 一、Redis简介Redis 是完全开源免费，遵守 BSD 协议的一个高性能的 key-value 数据库。 Redis 的特点： 性能极高; 提供 key-value, list, set, zset, hash 等数据结构的存储; 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作; 所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行; 二、Windows下安装和配置Redis1.安装前的注意事项 仅可在 Windows x64位 上安装 安装前请升级Windows上的 .NET Framework 至4.0版本以上，否则会安装程序会自动结束无法安装，可以在cmd中输入 dir %WINDIR%\\Microsoft.Net\\Framework\\v* /O:-N /B 命令查看当前安装的版本 2.下载安装包链接：Redis在GitHub上的项目网址 可以选择msi安装包或者zip压缩包下载，装好的内容是一样的，随意选。我这里选择msi安装包下载。 3.安装打开安装包，点击 Next 进入下一步； 同意用户许可协议，点击 Next 进入下一步； 选择安装路径，同时选中下面的复选框，把安装目录添加到系统环境变量； 设置端口，这里保持默认，选中下面的复选框，添加防火墙例外，保证外部可以正常访问Redis服务； 设置最大占用空间限制，可以不设置，我这里设置了10G的大小； 点击 Install 安装，Win10和Win7上会要求提供管理员权限，选 是 ； 等待安装完成，点击 Finish 退出安装程序； 下面是安装完成后的文件列表，同时系统环境变量 PATH 中会有安装目录的变量。 4.配置进入安装目录，使用文本编辑器（推荐Notepad++或Sublime）打开 redis.windows-service.conf 文件，注意是有 service 的文件，不是另一个！ 打开之后找到 requirepass 所在的行，在下面另起一行，写入 requirepass 123456 ，123456是redis的密码，可以自己设置； 完成后保存文件退出。 依次 右键点击”我的电脑” - 打开”管理” - “服务和应用程序” - “服务”，在右侧找到名为 Redis 的服务项，查看是否已启动。没有启动的话手动启动它。如果已经启动的话请停止后重新启动（为了刷新密码验证设置）。 三、检查是否安装成功1.进入Redis服务检验打开cmd窗口，输入 redis-cli 回车，如果显示了本地地址和端口号，则说明Redis服务正常。 2.Redis读写检验设置了密码之后，需要输入 auth 123456 使用密码来通过验证，显示 OK 则成功； 输入 set testkey &quot;hello redis&quot; 新增一个键值，再输入 get testkey 读取刚刚新建的键值，若能写入和读取则安装成功； 输入 del testkey 删除键值； 输入 exit 退出Redis。 四、参考资料 Redis官网 Redis的GitHub项目 Redis在线试用 Redis教程","categories":[{"name":"Windows工作环境搭建","slug":"Windows工作环境搭建","permalink":"https://ultronxr.xyz/categories/Windows工作环境搭建/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://ultronxr.xyz/tags/redis/"}]},{"title":"CentOS 7下搭建Kubernetes(k8s)集群","slug":"Create-a-kubernetes-cluster-on-CentOS7","date":"2018-08-08T16:00:00.000Z","updated":"2018-12-22T10:50:08.520Z","comments":true,"path":"2018/08/09/Create-a-kubernetes-cluster-on-CentOS7/","link":"","permalink":"https://ultronxr.xyz/2018/08/09/Create-a-kubernetes-cluster-on-CentOS7/","excerpt":"CentOS 7下搭建Kubernetes(k8s)集群","text":"CentOS 7下搭建Kubernetes(k8s)集群 一、参考网址Centos7.3安装Kubernetes集群","categories":[{"name":"Linux工作环境搭建","slug":"Linux工作环境搭建","permalink":"https://ultronxr.xyz/categories/Linux工作环境搭建/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ultronxr.xyz/tags/docker/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://ultronxr.xyz/tags/kubernetes/"}]},{"title":"Windows环境下安装Ruby组件和配置，以及利用jekyll和GitHub Pages在GitHub上搭建个人博客","slug":"Create-ruby-environment-in-Windows-and-build-your-own-github-blog-with-jekyll-and-GitHub-Pages","date":"2018-08-07T16:00:00.000Z","updated":"2018-12-22T10:50:12.213Z","comments":true,"path":"2018/08/08/Create-ruby-environment-in-Windows-and-build-your-own-github-blog-with-jekyll-and-GitHub-Pages/","link":"","permalink":"https://ultronxr.xyz/2018/08/08/Create-ruby-environment-in-Windows-and-build-your-own-github-blog-with-jekyll-and-GitHub-Pages/","excerpt":"Windows环境下安装Ruby组件和配置，以及利用jekyll和GitHub Pages在GitHub上搭建个人博客","text":"Windows环境下安装Ruby组件和配置，以及利用jekyll和GitHub Pages在GitHub上搭建个人博客 一、安装ruby和相关组件1.下载ruby在官网下载ruby安装包.注意不要下载最新的，有些组件可能不支持最新版的ruby. 选择下图的安装包，或者使用这里提供的链接直接下载ruby2.4.4x64的安装包. 2.安装ruby打开安装包，选择同意协议书点Next; 选择安装目录，我这里选择安装在 D:\\ruby_msys64 ，下面的三个选项都打勾; 点击Install之后弹出组件选择界面，这里的MSYS2一定要选上，点Next; 安装界面，等待安装完成; 安装完成之后直接点Finish，默认的勾勾着; 点击Finish后弹出来一个cmd窗口，有三个选项，输入3回车; 等待安装完成后的界面，回车退出 如果没有弹出cmd窗口，可以手动打开cmd窗口输入 ridk install ，会有和上一步同样的界面，按上一步做即可. 3.下载gem下载安装gem，官网截图如下，选择zip版本，直接下载链接; 4.安装gem把压缩包解压到指定文件夹，我这里是 D:\\ruby_msys64\\rubygems-2.7.7 ，下面是解压出来的文件; 打开cmd窗口，cd进入这个文件夹，输入 ruby setup.rb ，下面正常安装后的界面; 5.下载DevKit下载DevKit，官网，安装包直接下载链接; 6.安装DevKit打开安装包，选择目录，我这里解压到 D:\\ruby_msys64\\DevKit ，点Extract; 解压过程如下，等待解压完成; 这是解压出来的文件; 打开cmd，cd进入解压的路径，输入 ruby dk.rb init ，以下是初始化成功的界面; 输入 ruby dk.rb install ，以下是安装过程; 检查安装是否成功：输入 gem install rdiscount --platform=ruby ，如果正常安装显示以下界面，则安装成功; 二、修改源1.修改MSYS2的源教程链接 进入 D:\\ruby_msys64\\Ruby24-x64\\msys64\\etc\\pacman.d 目录： 编辑mirrorlist.mingw32 ，在文件开头添加： Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686 编辑mirrorlist.mingw64 ，在文件开头添加： Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64 编辑mirrorlist.msys ，在文件开头添加： Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/msys/$arch 然后打开 D:\\ruby_msys64\\Ruby24-x64\\msys64\\msys2.exe ，执行 pacman -Sy 刷新软件包数据即可. 2.修改gem的源教程链接 查看当前使用的源地址，输入 gem sources; 删除默认的源地址，输入： gem sources -r url地址 注：默认的url地址后必须有”/”,否则删不掉 添加国内的源地址: gem sources -a https://gems.ruby-china.com 更新源的缓存: gem sources -u 三、安装bundle和jekyll1.安装bundle打开cmd窗口，输入 gem install bundler 后回车，提示是否覆盖输入y回车。以下是bundle安装成功界面： 2.安装jekyll打开cmd窗口，输入gem install jekyll 后回车，这里需要耐心一点，会安装挺久的。以下是安装成功界面： 如果在”Building native extensions. This could take a while…”这里报错，说明DevKit没有安装好，验证安装DevKit是否成功那一步就应该通不过，重新安装DevKit即可。 四、搭建博客和本地调试1.第一种方法：直接fork别人现成的博客先创建一个GitHub账户，然后登录，balabala… 这里以fork我的博客为例，先进入我的仓库，点击右上角的fork按钮（我这里是自己看自己的仓库所以不能fork）; fork完后博客就在自己的仓库里了。如果有CNAME文件的话，把这个文件删除（这个文件是自定义域名的文件，不删掉的话会域名冲突），修改完成后点击Commit提交修改; 点击Settings按钮进入仓库设置; 先设置项目名称，改成 *.github.io 的形式，* 的位置是自己GitHub的用户名; 修改完成后向下拉，看到GitHub Pages的地方，显示 Your site is published at https://*.github.io 就可以了，你就可以通过浏览器访问这个网址，看到你的博客网站，只不过现在里面显示的还是我的内容，后面可以慢慢改; 然后使用git clone整个项目克隆到本地，进行修改; 根目录下部分文件夹的作用： 12345678910_config.yml : 全局配置文件，按照其中的注释说明修改成自己的内容README.md : 项目说明文件CNAME : 可能存在可能不存在，存在的话说明博客网站被解析到别的域名，域名记录在文件中_posts/ : 放博客文章的文件夹，里面的文件是markdown文件格式assets/ : 博客中用到的媒体等资源的文件_layouts/ : 博客页面的模版框架page/ : 主菜单中每个页面的模版框架其他的文件夹是各页面的HTML文件，你可以点进去看看，尝试改变一下 下面是博客页面的本地调试方法： 先把GitHub博客项目clone到本地; 打开cmd窗口，cd进入项目文件夹，输入 gem install github-pages ，系统会自动安装需要的组件，安装成功的界面如下; 在cmd窗口输入 jekyll server --watch 命令，显示如下，在浏览器里输入显示的Server address后面的网址就可以预览博客网站，按ctrl+c可以停止预览 调试完成后的博客可以push到GitHub项目仓库中. 2.第二种方法：自己在GitHub上新建一个GitHub Pages新建一个项目仓库，在仓库页面顶部点击New按钮; 在新建页面填写项目名称，博客的名称是 *.github.io 的形式， * 是自己的GitHub用户名，填写项目描述（可选），选择Public，创建一个README文件，完成后点击Create repository按钮，创建完成; 创建完成后在项目顶部点击Settings按钮进入设置; 下拉直到GitHub Pages的地方可以看到 Your site is published at https://*.github.io的信息，说明已经创建成功（可以通过浏览器访问这个网址进入博客页面），点击Choose a theme按钮选择博客的主题样式; 选择一个主题样式，点击Select theme按钮，完成选择; 跳转到README文件编辑页面，README文件主要记录着项目的相关信息和主题样式的相关信息等，可以自己修改内容，也可以下拉到底部点击Commit changes直接跳过这一步以后再修改; 新建项目完成后，可以尝试进入博客网址查看新建的博客页面; 用这种方法创建的博客的本地调试博客方法与第一种相同，调试完成后的博客可以push到GitHub项目仓库中. 3.使用jekyll在本地创建一个博客模版在本地cmd窗口运行jekyll new blog命令，会在本地创建一个完整的博客模版，创建的速度可能会很慢，和网速有关。创建的位置会在窗口中显示，可以把整个文件夹剪切到别的目录下; 根目录文件内容如下: 1234Gemfile : 内容是博客相关所需的组件_config.yml : 记录博客的配置内容_posts/ : 文件夹下是博客页面（markdown格式的页面，写也要按照这个格式） 打开cmd窗口，cd到文件夹的目录位置下，输入 bundle install 命令，命令会根据当前目录下的Gemfile，安装所需要的所有软件。这一步所安装的东西，可以说跟github本身的环境是完全一致的，所以可以确保本地如果没有错误，上传后也不会有错误；如果以后修改了Gemfile，可以执行 bundle update 命令进行更新; 下面是博客页面的本地调试方法： 在该路径下执行 bundle exec jekyll serve 命令，系统会在本地开启博客页面预览，在浏览器里输入Server address后面显示的网址就可以预览，使用ctrl+c关闭预览; 调试完成后的博客可以push到GitHub项目仓库中. 五、把你的博客解析到别的域名GitHub Pages的页面很难被百度等搜索引擎抓取，也就是说你的博客很难被别人发现，这时如果你有另外注册的域名，就可以用来解析这个博客网址.（或者使用Coding Net等第三方项目托管平台，我本人没试过，你们可以试试） 在项目的Settings下的GitHub Pages中的Custom domain修改（修改了这里就不用手动修改后面的CNAME文件了，系统会自动创建）; 或者在项目根目录下新建一个文件CNAME，里面写你的域名（域名不需要写https://www的部分），修改好后就可以在GitHub Pages的提示中看到 Your site is published at https://....... ，这样就可以通过自己的域名访问你的博客 六、博客页面的撰写markdownmarkdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等）. GitHub Pages上的博客页面都是使用markdown语言编写的，所以先学学markdown才能写博客（可能我以后会总结一下markdown的语法写个博客(挖坟预定)）. 博客文件的位置在根目录的 _post 文件夹下，命名规则为 yyyy-mm-dd-NameOfBlog.md 如 2018-01-01-my first blog.md . 七、其他jekyll主题官网里面有很多其他的主题，可以点此跳转. 找到合适的主题后点进去，可以直接Download，或者GitHub页面fork过来然后clone到本地修改. 别人创建的主题拿过来之后，需要修改其中的 _config.yml 配置文件，把里面的内容修改成自己的信息，同时其他内容的修改可以参照 README 文件 修改完成后可以本地预览调试，然后push到自己的GitHub;","categories":[{"name":"Windows工作环境搭建","slug":"Windows工作环境搭建","permalink":"https://ultronxr.xyz/categories/Windows工作环境搭建/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://ultronxr.xyz/tags/jekyll/"},{"name":"ruby","slug":"ruby","permalink":"https://ultronxr.xyz/tags/ruby/"},{"name":"blog","slug":"blog","permalink":"https://ultronxr.xyz/tags/blog/"}]}]}